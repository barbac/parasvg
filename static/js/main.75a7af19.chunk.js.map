{"version":3,"sources":["i18n.ts","editor/Handles.tsx","app/hooks.ts","editor/patternSlice.ts","editor/Guides.tsx","editor/GuideMeasurements.tsx","editor/points.ts","editor/Path.tsx","editor/toolsSlice.ts","app/store.ts","utils/serialization.ts","editor/BackgroundInput.tsx","editor/ControlsWrapper.tsx","editor/Parameters.tsx","editor/Controls.tsx","editor/ToolBox.tsx","editor/Editor.tsx","utils/gcode.ts","App.tsx","serviceWorker.js","index.tsx"],"names":["i18n","use","LanguageDetector","initReactI18next","init","resources","en","translation","Patterns","Save","Scale","Guides","gcode","Generate","Move","Mirror","Undo","Redo","es","interpolation","escapeValue","detection","order","Handles","vertices","onMouseDown","onClick","map","i","x","y","type","className","cx","cy","r","HANDLE_RADIUS","useAppDispatch","useDispatch","useAppSelector","useSelector","math","create","all","initialState","name","scale","mirror","guides","originIndex","pos","length","lengthExpresion","direction","label","parameters","Waist","Shoulder","calculateLength","guide","GUIDE_HORIZONTAL","originGuide","Math","round","updateAnchoredVertices","guideIndex","forEach","vertex","anchorY","GUIDE_VERTICAL","anchorX","computeGuideLength","state","guideLength","scope","parameter","key","evaluate","e","console","log","patternSlice","createSlice","reducers","setPattern","action","payload","setName","setScale","oldScale","scaleFactor","oldLength","setMirror","toggleMirror","clearVertices","setVertices","addVertex","push","setVertexValue","index","clearGuides","addGuide","lastIndex","lastGuide","setGuideLabel","setGuidePos","len","nonOriginGuide","setGuideLength","setParameterValue","value","finishDragging","actions","selectPattern","pattern","present","selectMirror","selectVertices","selectGuides","selectParameters","width","height","points","x1","x2","y1","y2","InputField","children","firstPoint","t","useTranslation","useState","visible","setVisible","dispatch","stopPropagation","placeholder","onChange","target","GuideMeasurements","hGuides","vGuides","firstHPoint","shift","firstVPoint","distance","abs","textY","textX","mirrorPoints","stopIndex","newVertices","delta","newVertex","Path","spline","commands","path","join","d","stroke","strokeWidth","strokeOpacity","opacity","fillOpacity","toolSlice","toolMode","selectToolMode","setToolState","toolbox","store","configureStore","reducer","undoable","patternReducer","filter","excludeAction","toolsReducer","PATTERN_NAME_PREFIX","functions","load","patternString","window","localStorage","getItem","JSON","parse","sample2","sample1","save","getState","setItem","stringify","BackgroundInput","accept","reader","FileReader","file","files","onload","result","readAsDataURL","QUERY_STRING","ControlsWrapper","open","setOpen","matches","matchMedia","useLayoutEffect","style","display","Parameters","parametersList","intputFields","fields","valueAsNumber","Number","isNaN","marginBottom","Controls","image","onBackgroundSelected","onNewAction","onSaveAction","onLoadAction","onGcodeAction","guideInputs","imageFileName","setImageFileName","patternNames","Object","keys","indexOf","replace","sample1Label","options","changeLanguage","filename","img","readOnly","select","BUTTON_LENGHT","Button","title","tool","SvgPathButton","props","ToolBox","viewBox","fill","ActionCreators","undo","redo","TOOL_TYPES","TOOL_KEYS","KeyN","KeyP","KeyH","KeyV","KeyC","KeyS","Editor","svg","toolState","_setToolState","handleDraggingIndex","setHandleDraggingIndex","guideDraggingIndex","setGuidDraggingIndex","setImage","gcodeString","setGcodeString","createGuide","guideType","pt","createSVGPoint","clientX","clientY","cursorpt","matrixTransform","getScreenCTM","inverse","handleGcodeAction","first","oldVertices","g1Commands","control","Bezier","getLUT","step","TOOL_FUNCTIONS","move","handle","altKey","hguide","vguide","viewBoxWidth","border","serialization","id","ref","onMouseUp","onMouseMove","snapHGuide","snapHGuideIndex","newDistance","snapVGuide","snapVGuideIndex","error","tabIndex","onKeyPress","code","shiftKey","reversedVertices","reverse","yAxis","reflectedVertices","href","newVertexs","splice","App","Boolean","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"q7IAqDAA,IACGC,IAAIC,KACJD,IAAIE,KACJC,KAAK,CACJC,UArDqB,CACvBC,GAAI,CACFC,YAAa,CACX,cAAe,cACfC,SAAU,WACV,WAAY,WACZC,KAAM,OACN,uBAAwB,uBACxB,mBAAoB,mBACpBC,MAAO,QACPC,OAAQ,SACRC,MAAO,QACPC,SAAU,WAEVC,KAAM,OACN,iBAAkB,iBAClB,mBAAoB,mBACpB,aAAc,aACd,mBAAoB,mBACpBC,OAAQ,SACRC,KAAM,OACNC,KAAM,SAGVC,GAAI,CACFX,YAAa,CACX,cAAe,kBACfC,SAAU,WACV,WAAY,eACZC,KAAM,UACN,uBAAwB,2BACxB,mBAAoB,kBACpBC,MAAO,SACPC,OAAQ,WACRC,MAAO,QACPC,SAAU,UAEVC,KAAM,QACN,iBAAkB,mBAClB,mBAAoB,qBACpB,aAAc,qBACd,mBAAoB,oBACpBC,OAAQ,WACRC,KAAM,WACNC,KAAM,aAURE,cAAe,CACbC,aAAa,GAEfC,UAAW,CACTC,MAAO,CAAC,eAAgB,YAAa,c,+CCpD5B,SAASC,EAAT,GAIG,IAHhBC,EAGe,EAHfA,SACAC,EAEe,EAFfA,YACAC,EACe,EADfA,QAEA,OACE,mCACGF,EAASG,KAAI,WAAiBC,GAAjB,IAAGC,EAAH,EAAGA,EAAGC,EAAN,EAAMA,EAAGC,EAAT,EAASA,KAAT,OACZ,oBAEEC,UAAU,SACVP,YAAa,kBAAMA,EAAYG,IAC/BF,QAAS,kBAAMA,EAAQE,IAJzB,UAME,wBACEK,GAAIJ,EACJK,GAAIJ,EACJE,UAAS,UAAKJ,EAAIG,EAAO,SACzBI,EApBU,IAsBZ,sBAAMN,EAAGA,EAAIO,EAAmBN,EAAGA,EAAIM,EAAvC,SACGR,MAZEA,Q,YCfFS,EAAiB,kBAAMC,eACvBC,EAAkDC,I,wBCCzDC,EAAOC,YAAOC,KAgBdC,EAA6B,CACjCC,KAAM,GACNC,MAAO,EACPC,QAAQ,EACRvB,SAAU,GACVwB,OAAQ,CAEN,CACEjB,KAAM,IACNkB,YAAa,KAEbC,IAAK,IACLC,OAAQ,IACRC,gBAAiB,IACjBC,UAAW,EACXC,MAAO,IAET,CACEvB,KAAM,IACNkB,YAAa,KACbC,IAAK,GACLC,OAAQ,GACRC,gBAAiB,GACjBC,UAAW,EACXC,MAAO,KAGXC,WAAY,CACV,CACEV,KAAM,OACNU,WAAY,CACVC,MAAO,GACPC,SAAU,KAGd,CACEZ,KAAM,gBACNU,WAAY,CACV,cAAe,MAgCvB,SAASG,EAAgBC,EAAcX,EAAiBF,GACtD,IAAIK,EAAS,EACb,GAAIQ,EAAM5B,OAAS6B,EAAkB,CAEnCT,GADoBH,EA7BO,GA8BLE,IAAMS,EAAMT,KAAOJ,MACpC,CACL,IAAMe,EAAcb,EA/BK,GAgCzBG,GAAUQ,EAAMT,IAAMW,EAAYX,KAAOJ,EAI3C,OADAK,EAASW,KAAKC,MAAe,IAATZ,GAAgB,IAItC,SAASa,EACPxC,EACAmC,EACAM,GAEAzC,EAAS0C,SAAQ,SAACC,GACZR,EAAM5B,OAAS6B,GAAoBO,EAAOC,UAAYH,EACxDE,EAAOrC,EAAI6B,EAAMT,IACRS,EAAM5B,OAASsC,GAAkBF,EAAOG,UAAYL,IAC7DE,EAAOtC,EAAI8B,EAAMT,QAKvB,SAASqB,EACPnB,EACAa,EACAO,GAGA,KAAIP,EA1D0B,GA0D9B,CAIA,IAAIN,EAAQa,EAAMxB,OAAOiB,GACzBN,EAAMP,gBAAkBA,EAExB,IAAIqB,EAAc,EAClB,IAEE,IAAIC,EAAmC,GACvCF,EAAMjB,WAAWW,SAAQ,SAACS,GACxB,IAAK,IAAMC,KAAOD,EAAUpB,WAC1BmB,EAAME,GAAOD,EAAUpB,WAAWqB,MAGtCJ,EAAMxB,OAAOkB,SAAQ,SAACP,GAChBA,EAAML,QACRoB,EAAMf,EAAML,OAASK,EAAMR,WAI/BsB,EAAchC,EAAKoC,SAAL,UAAiBzB,GAAmBsB,GAClD,MAAOI,GAGP,YADAC,QAAQC,IAAIF,GAGd,GAA2B,kBAAhBL,EAAX,CAKA,GADAd,EAAMR,OAASsB,EACXd,EAAM5B,OAAS6B,EAAkB,CACnC,IAAMC,EAAcW,EAAMxB,OA9FC,GA+F3BW,EAAMT,IAAMW,EAAYX,IAAMS,EAAMR,OAASqB,EAAM1B,UAC9C,CACL,IAAMe,EAAcW,EAAMxB,OAhGD,GAiGzBW,EAAMT,IAAMW,EAAYX,IAAMS,EAAMR,OAASqB,EAAM1B,MAGrDkB,EAAuBQ,EAAMhD,SAAUmC,EAAOM,KAGzC,IAAMgB,EAAeC,YAAY,CACtCrC,KAAM,UACND,eACAuC,SAAU,CACRC,WAAY,SAACZ,EAAOa,GAClBN,QAAQC,IAAI,iBACZ,MACEK,EAAOC,QADDzC,EAAR,EAAQA,KAAMC,EAAd,EAAcA,MAAOC,EAArB,EAAqBA,OAAQvB,EAA7B,EAA6BA,SAAUwB,EAAvC,EAAuCA,OAAQO,EAA/C,EAA+CA,WAE/CiB,EAAM3B,KAAOA,EACb2B,EAAM1B,MAAQA,EACd0B,EAAMzB,OAASA,EACfyB,EAAMhD,SAAWA,EACjBgD,EAAMxB,OAASA,EACfwB,EAAMjB,WAAaA,GAErBgC,QAAS,SAACf,EAAOa,GACfb,EAAM3B,KAAOwC,EAAOC,SAEtBE,SAAU,SAAChB,EAAOa,GAChB,IAAMI,EAAWjB,EAAM1B,MACvB0B,EAAM1B,MAAQuC,EAAOC,QACrB,IAAMI,EAAclB,EAAM1B,MAAQ2C,EAClCjB,EAAMxB,OAAOkB,SAAQ,SAACP,EAAO/B,GAC3B,IAAM+D,EAAYhC,EAAMR,OACxBQ,EAAMR,QAAUuC,EAChB/B,EAAMR,OAASW,KAAKC,MAAqB,IAAfJ,EAAMR,QAAgB,IAC5CQ,EAAMP,kBAAoBuC,IAC5BhC,EAAMP,gBAAkBO,EAAMR,QAEhCqB,EAAMxB,OAAOkB,SAAQ,SAACP,EAAO/B,GAC3B2C,EAAmBZ,EAAMP,gBAAiBxB,EAAG4C,UAInDoB,UAAW,SAACpB,EAAOa,GACjBb,EAAMzB,OAASsC,EAAOC,SAExBO,aAAc,SAACrB,EAAOa,GACpBb,EAAMzB,QAAUyB,EAAMzB,QAExB+C,cAAe,SAACtB,EAAOa,GACrBb,EAAMhD,SAAW,IAEnBuE,YAAa,SAACvB,EAAOa,GACnBb,EAAMhD,SAAW6D,EAAOC,SAE1BU,UAAW,SAACxB,EAAOa,GACjBb,EAAMhD,SAASyE,KAAKZ,EAAOC,UAE7BY,eAAgB,SAAC1B,EAAOa,GACtBb,EAAMhD,SAAS6D,EAAOC,QAAQa,OAASd,EAAOC,QAAQnB,QAExDiC,YAAa,SAAC5B,EAAOa,GACnBb,EAAMxB,OAAN,YAAmBJ,EAAaI,SAElCqD,SAAU,SAAC7B,EAAOa,GAChB,IAAMiB,EAAY9B,EAAMxB,OAAOiD,KAAKZ,EAAOC,SAAW,EAClDiB,EAAY/B,EAAMxB,OAAOsD,GAC7BC,EAAUpD,OAASO,EAAgB6C,EAAW/B,EAAMxB,OAAQwB,EAAM1B,OAClEyD,EAAUnD,gBAAkBmD,EAAUpD,QAExCqD,cAAe,SACbhC,EACAa,GAEAb,EAAMxB,OAAOqC,EAAOC,QAAQa,OAAO7C,MAAQ+B,EAAOC,QAAQhC,OAE5DmD,YAAa,SAACjC,EAAOa,GACnB,IAAMpB,EAAaoB,EAAOC,QAAQa,MAC9BxC,EAAQa,EAAMxB,OAAOiB,GACzB,EAAiBoB,EAAOC,QAAhBzD,EAAR,EAAQA,EAAGC,EAAX,EAAWA,EAEX,GADA6B,EAAMT,IAAMS,EAAM5B,OAAS6B,EAAmB9B,EAAID,EAC9CoC,EA9KsB,EA8KgB,CAExCN,EAAMR,OAAS,EAGf,IACE,IAAIvB,EApLkB,EAoLW8E,EAAMlC,EAAMxB,OAAOG,OACpDvB,EAAI8E,EACJ9E,IACA,CACA,IAAI+E,EAAiBnC,EAAMxB,OAAOpB,GAC9B+E,EAAe5E,OAAS4B,EAAM5B,OAC5B4E,EAAexD,SAAWwD,EAAevD,iBAC3CuD,EAAexD,OAASO,EACtBiD,EACAnC,EAAMxB,OACNwB,EAAM1B,OAER6D,EAAevD,gBAAkBuD,EAAexD,QAEhDoB,EAAmBoC,EAAevD,gBAAiBxB,EAAG4C,UAK5Db,EAAMR,OAASO,EAAgBC,EAAOa,EAAMxB,OAAQwB,EAAM1B,OAC1Da,EAAMP,gBAAkBO,EAAMR,OAGhCa,EAAuBQ,EAAMhD,SAAUmC,EAAOM,IAEhD2C,eAAgB,SAACpC,EAAOa,GACtB,IAAMpB,EAAaoB,EAAOC,QAAQa,MAClC5B,EAAmBc,EAAOC,QAAQnC,OAAQc,EAAYO,IAExDqC,kBAAmB,SAACrC,EAAOa,GACzBb,EAAMjB,WAAW8B,EAAOC,QAAQa,OAAO5C,WAAW8B,EAAOC,QAAQzC,MAC/DwC,EAAOC,QAAQwB,MACjBtC,EAAMxB,OAAOkB,SAAQ,SAACP,EAAO/B,GAC3B2C,EAAmBZ,EAAMP,gBAAiBxB,EAAG4C,OAGjDuC,eAAgB,SAACvC,EAAOa,QAMrB,EAgBHJ,EAAa+B,QAffzB,EADK,EACLA,QACAC,EAFK,EAELA,SAEAK,GAJK,EAGLD,UAHK,EAILC,cACAC,EALK,EAKLA,cACAC,EANK,EAMLA,YACAC,EAPK,EAOLA,UACAE,EARK,EAQLA,eACAE,EATK,EASLA,YACAC,EAVK,EAULA,SACAG,EAXK,EAWLA,cACAC,EAZK,EAYLA,YACAG,EAbK,EAaLA,eACAC,EAdK,EAcLA,kBACAE,EAfK,EAeLA,eAEWE,EAAgB,SAACzC,GAAD,OAAsBA,EAAM0C,QAAQC,SACpDC,EAAe,SAAC5C,GAAD,OAAsBA,EAAM0C,QAAQC,QAAQpE,QAC3DsE,EAAiB,SAAC7C,GAAD,OAC5BA,EAAM0C,QAAQC,QAAQ3F,UACX8F,EAAe,SAAC9C,GAAD,OAAsBA,EAAM0C,QAAQC,QAAQnE,QAC3DuE,EAAmB,SAAC/C,GAAD,OAC9BA,EAAM0C,QAAQC,QAAQ5D,YACT0B,IAAf,QCpTarB,EAAmB,IACnBS,EAAiB,IAkBvB,SAAS1D,EAAT,GAA8D,IAA5C6G,EAA2C,EAA3CA,MAAOC,EAAoC,EAApCA,OAAQhG,EAA4B,EAA5BA,YAChCuB,EAAST,EAAe+E,GAC9B,OACE,mCACGtE,EAAOrB,KAAI,WAAgBC,GAAO,IAApBsB,EAAmB,EAAnBA,IACTwE,EAAS,GAiBb,OAfEA,EAH8B,EAAd3F,OAEL6B,EACF,CACP+D,GAAI,EACJC,GAAIJ,EACJK,GAAI3E,EACJ4E,GAAI5E,GAGG,CACPyE,GAAIzE,EACJ0E,GAAI1E,EACJ2E,GAAI,EACJC,GAAIL,GAKN,oBAAGzF,UAAU,QAAQP,YAAa,kBAAMA,EAAYG,IAApD,UACE,gDAAU8F,GAAV,IAAkB1F,UAAU,WAC5B,oCAAU0F,MAFiD9F,Q,YC1BvE,SAASmG,EAAT,GAOqB,IANnBlG,EAMkB,EANlBA,EACAC,EAKkB,EALlBA,EACAqE,EAIkB,EAJlBA,MAGA6B,GACkB,EAHlBC,WAGkB,EAFlBnF,MAEkB,EADlBkF,UAEQE,EAAMC,cAAND,EACR,EAA8BE,oBAAS,GAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KACMC,EAAWlG,IACXsB,EAAQpB,EAAe+E,GAAcnB,GAE3C,OACE,oBAAGnE,UAAU,cAAcN,QAAS,kBAAM4G,GAAYD,IAAtD,UACGL,EACAK,EACC,+BAAeb,MAAM,MAAMC,OAAO,QAAQ5F,EAAGA,EAAI,IAAKC,EAAGA,EAAI,GAA7D,SACE,uBACEJ,QAAS,SAACoD,GAAD,OAAOA,EAAE0D,mBAClBzG,KAAK,OACL+E,MAAOnD,EAAML,MACbmF,YAAaP,EAAE,SACfQ,SAAU,SAAC5D,GAAD,OACRyD,EAAS/B,EAAc,CAAElD,MAAOwB,EAAE6D,OAAO7B,MAAOX,gBAKtD,sBAAMtE,EAAGA,EAAGC,EAAGA,EAAf,SACG6B,EAAML,QAGV+E,GACC,+BAAeb,MAAM,MAAMC,OAAO,QAAQ5F,EAAGA,EAAI,GAAIC,EAAGA,EAAI,GAA5D,SACE,uBACEJ,QAAS,SAACoD,GAAD,OAAOA,EAAE0D,mBAClBzG,KAAK,OACL0G,YAAaP,EAAE,SACfpB,MAAOnD,EAAMP,gBACbsF,SAAU,SAAC5D,GACT,IAAMgC,EAAQhC,EAAE6D,OAAO7B,MACvByB,EAAS3B,EAAe,CAAEzD,OAAQ2D,EAAOX,mBASxC,SAASyC,EAAT,GAIa,IAH1BpB,EAGyB,EAHzBA,MACAC,EAEyB,EAFzBA,OACA3E,EACyB,EADzBA,MAEME,EAAST,EAAe+E,GAC1BuB,EAAsB,GACtBC,EAAsB,GAC1B9F,EAAOkB,SAAQ,WAAwBtC,GAAO,IAA5BsB,EAA2B,EAA3BA,IAAKC,EAAsB,EAAtBA,OAAsB,EAAdpB,OAChB6B,EACXiF,EAAQ5C,KAAK,CAAC/C,EAAKC,EAAQvB,IAE3BkH,EAAQ7C,KAAK,CAAC/C,EAAKC,EAAQvB,OAI/B,IAAMmH,EAAsBF,EAAQ1F,OAAS0F,EAAQG,QAAS,GAAK,EAC7DC,EAAsBH,EAAQ3F,OAAS2F,EAAQE,QAAS,GAAK,EAEnE,OACE,qCACGH,EAAQlH,KAAI,WAA4BC,GAAO,IAAD,mBAAhCsB,EAAgC,KAA3BC,EAA2B,KAAnBc,EAAmB,KACvCiF,EAAWpF,KAAKqF,IAAIjG,EAAM6F,GAC1BlH,EAAK2F,GAASqB,EAAQ1F,OAAS,IAAOvB,EAAI,GAC1CwH,EAAQL,EAAcG,EAAW,EACjCxB,EAAS,CACbC,GAAI9F,EACJ+F,GAAI/F,EACJgG,GAAI3E,EACJ4E,GAAIiB,GAGN,OACE,eAAChB,EAAD,CACElG,EAAGA,EACHC,EAAGsH,EAAQ,EACXjD,MAAOlC,EACPgE,WAAYgB,EACZnG,MAAOA,EALT,UAQE,oCAAU4E,IACV,0BACEA,OAAM,UAAK7F,EAAL,YAAUqB,EAAV,YAAiBrB,EA9Gb,EA8GJ,YACJqB,EA/GQ,EA8GJ,YAEFrB,EAhHM,EA8GJ,YAEqBqB,EAhHjB,EA8GJ,YAE8CrB,EAF9C,YAEmDqB,KAE3D,0BACEwE,OAAM,UAAK7F,EAAL,YAAUkH,EAAV,YAAyBlH,EAnHrB,EAmHJ,YACJkH,EApHQ,EAmHJ,YAEFlH,EArHM,EAmHJ,YAGJkH,EAtHQ,EAmHJ,YAIFlH,EAJE,YAIGkH,KAEX,sBAAMlH,EAAGA,EAAGC,EAAGsH,EAAQ,GAAvB,SACGjG,MAhBEvB,EAAI,QAsBdkH,EAAQnH,KAAI,WAA4BC,GAAO,IAAD,mBAAhCsB,EAAgC,KAA3BC,EAA2B,KAAnBc,EAAmB,KACvCiF,EAAWpF,KAAKqF,IAAIjG,EAAM+F,GAC1BnH,EAAK2F,GAAUqB,EAAQ3F,OAAS,IAAOvB,EAAI,GAC3CyH,EAAQJ,EAAcC,EAAW,EACjCxB,EAAS,CACbC,GAAIsB,EACJrB,GAAI1E,EACJ2E,GAAI/F,EACJgG,GAAIhG,GAGN,OACE,eAACiG,EAAD,CACElG,EAAGwH,EACHvH,EAAGA,EAAI,EACPqE,MAAOlC,EACPgE,WAAYgB,EACZnG,MAAOA,EALT,UAQE,oCAAU4E,IACV,0BACEA,OAAM,UAAKuB,EAAL,YAAoBnH,EAApB,YAAyBmH,EAtJrB,EAsJJ,YACJnH,EAvJQ,EAsJJ,YAEFmH,EAxJM,EAsJJ,YAGJnH,EAzJQ,EAsJJ,YAIFmH,EAJE,YAIanH,KAErB,0BACE4F,OAAM,UAAKxE,EAAL,YAAYpB,EAAZ,YAAiBoB,EA7Jb,EA6JJ,YACJpB,EA9JQ,EA6JJ,YAEFoB,EA/JM,EA6JJ,YAEuBpB,EA/JnB,EA6JJ,YAE8CoB,EAF9C,YAEqDpB,KAE7D,sBAAMA,EAAGA,EAAI,GAAID,EAAGwH,EAApB,SACGlG,MAhBEvB,EAAI,WChJd,SAAS0H,EAAa9H,GAC3B,GAAIA,EAAS2B,OAAS,EACpB,OAAO3B,EAET,IAAM+H,EAAY/H,EAAS2B,OAAS,EAChCqG,EAA6B,GACjChI,EAAS0C,SAAQ,SAACC,EAAQvC,GACpBA,IAAM2H,GAGVC,EAAYvD,KAAK9B,MAKnB,IAFA,IACMsF,EAAgB,EADRjI,EAAS+H,GAAW1H,EAEzBD,EAAI2H,EAAW3H,GAAK,EAAGA,IAAK,CACnC,IAAMuC,EAAS3C,EAASI,GAClB8H,EAAiB,eAAQvF,GAC/BuF,EAAU7H,EAAI4H,EAAQtF,EAAOtC,EAC7B2H,EAAYvD,KAAKyD,GAEnB,OAAOF,EAGMF,SCzBA,SAASK,GAAT,GAAgD,IAAhCnI,EAA+B,EAA/BA,SAAUuB,EAAqB,EAArBA,OACvC,IAAKvB,EAAS2B,OACZ,OAAO,KAGT3B,EAAWuB,EAASuG,EAAa9H,GAAYA,EAE7C,IAAIoI,GAAS,EACPC,EAAWrI,EAASG,KAAI,SAACwC,EAAQvC,GACrC,IAAQC,EAASsC,EAATtC,EAAGC,EAAMqC,EAANrC,EACX,MAAoB,YAAhBqC,EAAOpC,MACT6H,GAAS,EACH,KAAN,OAAY/H,EAAZ,YAAiBC,IAEb8H,GACFA,GAAS,EACH,IAAN,OAAW/H,EAAX,aAAiBC,IAEb,KAAN,OAAYD,EAAZ,aAAkBC,MAIhBgI,EACJ,YAAKtI,EAAS,GAAGK,EAAjB,aAAuBL,EAAS,GAAGM,EAAnC,MAA2C+H,EAASE,KAAK,MAAQ,KAEnE,OACE,sBACE/H,UAAU,OACVgI,EAAGF,EACHG,OAAO,eACPC,YAAY,IACZC,cAAc,IACdC,QAAQ,IACRC,YAAY,M,aC7BlB,IAIaC,GAAYpF,YAAY,CACnCrC,KAAM,QACND,aANmB,CACnB2H,SAAU,QAMVpF,SAAU,CACRqF,eAAgB,SAAChG,EAAOa,GACtBb,EAAM+F,SAAWlF,EAAOC,SAE1BmF,aAAc,SAACjG,EAAOa,GACpBb,EAAM+F,SAAWlF,EAAOC,YAKfmF,GAAiBH,GAAUtD,QAA3ByD,aACFD,GAAiB,SAAChG,GAAD,OAAsBA,EAAMkG,QAAQH,UACnDD,MAAf,Q,oBCzBaK,GAAQC,YAAe,CAClCC,QAAS,CACP3D,QAAS4D,KAASC,EAAgB,CAChCC,OAAQC,yBAAc,CAAC,sBAAuB,6BAEhDP,QAASQ,M,kBCNPC,GAAsB,WAqC5B,IAIeC,GAJG,CAChBC,KApCF,SAAcxI,GAGZ,GAFAkC,QAAQC,IAAI,cACS,6BACjBnC,EAAJ,CAKA,GADqB,8BACjBA,EAAJ,CAKA,IAAMyI,EAAgBC,OAAOC,aAAaC,QAAQN,GAAsBtI,GACxE,GAAKyI,EAAL,CAIA,IAAMpE,EAAUwE,KAAKC,MAAML,GAC3BvG,QAAQC,IAAIkC,GACZyD,GAAMpC,SAAS,CAAExG,KAAM,qBAAsBuD,QAAS4B,SALpDnC,QAAQC,IAAR,mBAAwBnC,EAAxB,cAA0CA,QAN1C8H,GAAMpC,SAAS,CAAExG,KAAM,qBAAsBuD,QAASsG,UALtDjB,GAAMpC,SAAS,CAAExG,KAAM,qBAAsBuD,QAASuG,MAiCxDC,KAdF,WACE,IAAM5E,EAAUyD,GAAMoB,WAAW7E,QAAQC,QACpB,KAAjBD,EAAQrE,OAGZkC,QAAQC,IAAI,SAAUkC,GACtBqE,OAAOC,aAAaQ,QAClBb,GAAsBjE,EAAQrE,KAC9B6I,KAAKO,UAAU/E,OC/BJ,SAASgF,GAAT,GAA8D,IAAnCxD,EAAkC,EAAlCA,SAChCR,EAAMC,cAAND,EACR,OACE,gCACE,8BAAMA,EAAE,sBACR,8BACE,uBACEnG,KAAK,OACLoK,OAAO,UACPzD,SAAU,SAAC5D,GACT,IAAMsH,EAAS,IAAIC,WACbC,EAAOxH,EAAE6D,OAAO4D,MAAO,GAC7BH,EAAOI,OAAS,SAAC1H,GAAD,OACd4D,EAAS4D,EAAKzJ,KAAMiC,EAAE6D,OAAQ8D,SAChCL,EAAOM,cAAc5H,EAAE6D,OAAO4D,MAAO,YCbjD,IAAMI,GAAe,uCACd,SAASC,GAAT,GAAyE,IAA9C5K,EAA6C,EAA7CA,UAAWgG,EAAkC,EAAlCA,SAC3C,EAAwBI,oBAAS,GAAjC,mBAAOyE,EAAP,KAAaC,EAAb,KACMC,EAAUxB,OAAOyB,WAAWL,IAAcI,QAQhD,OAPAE,2BAAgB,WAEK1B,OAAOyB,WAAWL,IAAcI,SAEjDD,GAAQ,KAET,CAACC,IAEF,sBAAK/K,UAAWA,EAAhB,UACE,wBAAQA,UAAU,kBAAkBN,QAAS,SAACoD,GAAD,OAAOgI,GAASD,IAA7D,SACGA,EAAO,IAAM,MAEhB,qBAAKK,MAAO,CAAEC,QAASN,EAAO,GAAK,QAAnC,SAA8C7E,OCpBrC,SAASoF,KACtB,IAAMC,EAAiB9K,EAAegF,GAChCgB,EAAWlG,IAEXiL,EAAeD,EAAe1L,KAAI,WAAuBC,GAAO,IAA3BiB,EAA0B,EAA1BA,KAAMU,EAAoB,EAApBA,WACzCgK,EAAS,GADoD,WAExD3I,GACT2I,EAAOtH,KACL,gCACE,8BAAMrB,IACN,uBACE7C,KAAK,SACL+E,MAAOvD,EAAWqB,GAClB8D,SAAU,SAAC5D,GACT,IAAMgC,EAAQhC,EAAE6D,OAAO6E,cAClBC,OAAOC,MAAM5G,IAChByB,EAAS1B,EAAkB,CAAEV,MAAOvE,EAAGiB,KAAM+B,EAAKkC,gBARhDlC,KAFd,IAAK,IAAMA,KAAOrB,EAAa,EAApBqB,GAkBX,OACE,gCACGhD,GAAK,sCACN,qBAAKsL,MAAO,CAAES,aAAc,IAA5B,SAAmC9K,IACnC,mCAAG0K,MAHK1K,MAOd,OAAO,qBAAKb,UAAU,aAAf,SAA6BsL,ICVvB,SAASM,GAAT,GAQG,EAPhBC,MAOiB,IANjBC,EAMgB,EANhBA,qBACAC,EAKgB,EALhBA,YACAC,EAIgB,EAJhBA,aACAC,EAGgB,EAHhBA,aACArN,EAEgB,EAFhBA,MACAsN,EACgB,EADhBA,cAEQhG,EAAMC,cAAND,EACFK,EAAWlG,IAGX8L,EADS5L,EAAe+E,GACH3F,KAAI,WAA6BC,GAAO,IAAjCwB,EAAgC,EAAhCA,gBAAiBE,EAAe,EAAfA,MACjD,OAAI1B,EAAI,EAEC,KAGP,gCACE,8BAAM0B,GAAS1B,EAAI,IACnB,8BACE,uBACEG,KAAK,OACL+E,MAAO1D,EACPsF,SAAU,SAAC5D,GACT,IAAMgC,EAAQ,CACZ3D,OAAQ2B,EAAE6D,OAAO7B,MACjBX,MAAOvE,GAET2G,EAAS3B,EAAeE,WAXtBlF,MAmBd,EAA0CwG,mBAAS,IAAnD,mBAAOgG,EAAP,KAAsBC,EAAtB,KACMnH,EAAU3E,EAAe0E,GAEzBkE,EAAsB,WACtBmD,EAAY,CAChB,IADgB,mBAEbC,OAAOC,KAAKjD,OAAOC,cACnBR,QAAO,SAACnI,GACP,OAAQA,EAAK4L,QAAQtD,MAEtBxJ,KAAI,SAACkB,GAAD,OAAUA,EAAK6L,QAAQvD,EAAqB,SAI/CwD,EAAe,2BAChBpD,OAAOC,aAAaC,QAAQkD,IAC/BL,EAAarI,KAAK0I,GAGfpD,OAAOC,aAAaC,QAAQ,8BAC/B6C,EAAarI,KAFM,6BAMrB,IAAM2I,EAAUN,EAAa3M,KAAI,SAACkB,GAAD,OAC/B,wBAAmBiE,MAAOjE,EAA1B,SACGA,GADUA,MAKf,OACE,cAAC+J,GAAD,CAAiB5K,UAAU,WAA3B,SACE,iCACE,gCACE,uBACED,KAAK,SACL+E,MAAM,UACNpF,QAAS,kBAAM1B,IAAK6O,eAAe,SAErC,uBACE9M,KAAK,SACL+E,MAAM,aACNpF,QAAS,kBAAM1B,IAAK6O,eAAe,YAIvC,8BACE,8BACE,uBACE9M,KAAK,SACL+E,MAAOoB,EAAE,eACTxG,QAAS,kBAAMqM,WAKrB,gCACE,8BAAM7F,EAAE,cACR,8BACE,wBAAQQ,SAAU,SAAC5D,GAAD,OAAOmJ,EAAanJ,EAAE6D,OAAO7B,QAA/C,SACG8H,SAKP,gCACE,8BAAM1G,EAAE,cACR,8BACE,uBACEnG,KAAK,OACL+E,MAAOI,EAAQrE,KACf6F,SAAU,SAAC5D,GAAD,OAAOyD,EAAShD,EAAQT,EAAE6D,OAAO7B,aAG/C,8BACE,uBACEA,MAAOoB,EAAE,QACTnG,KAAK,SACLL,QAAS,kBAAMsM,YAKrB,gCACE,8BAAM9F,EAAE,0BACR,8BACE,uBACEnG,KAAK,OACL+E,MAAOsH,EACP1F,SAAU,SAAC5D,GACT,IAAMgC,EAAQhC,EAAE6D,OAAO7B,MACvBuH,EAAiBvH,GACjBgH,EAAqBhH,WAM7B,cAACoF,GAAD,CACExD,SAAU,SAACoG,EAAUC,GACnBV,EAAiBS,GACjBhB,EAAqBiB,MAIzB,gCACE,8BAAM7G,EAAE,WACR,8BACE,uBACEnG,KAAK,SACL+E,MAAOI,EAAQpE,MACf4F,SAAU,SAAC5D,GAAD,OAAOyD,EAAS/C,EAASV,EAAE6D,OAAO6E,wBAKlD,8BAAMtF,EAAE,gBACR,cAACkF,GAAD,IAEA,8BAAMlF,EAAE,YACPiG,EAED,gCACE,8BAAMjG,EAAE,WACR,8BACE,uBACEnG,KAAK,SACL+E,MAAOoB,EAAE,YACTxG,QAAS,kBAAMwM,SAGnB,0BACEpH,MAAOlG,EACPoO,UAAU,EACVtN,QAAS,SAACoD,GAAD,OAAQA,EAAE6D,OAA+BsG,oB,yBCxLxDC,GAAgB,GAKtB,SAASC,GAAT,GAA4E,IAA1DC,EAAyD,EAAzDA,MAAOC,EAAkD,EAAlDA,KAAM9E,EAA4C,EAA5CA,SAAU7I,EAAkC,EAAlCA,QAASsG,EAAyB,EAAzBA,SAChD,OACE,wBACEoH,MAAOA,EACPpN,UAAWuI,IAAa8E,EAAO,SAAW,GAC1C3N,QAAS,kBAAMA,KAHjB,SAKGsG,IASP,SAASsH,GAAT,GAAgE,IAAvCxF,EAAsC,EAAtCA,KAASyF,EAA6B,mBAC7D,OACE,cAACJ,GAAD,2BAAYI,GAAZ,aACE,qBAAK/H,MAAO0H,GAAezH,OAAQyH,GAAnC,SACE,sBAAMlF,EAAGF,EAAMO,YAAY,YAcpB,SAASmF,KACtB,IAAMjH,EAAWlG,IACXU,EAASR,EAAe6E,GACxBmD,EAAWhI,EAAeiI,IACxBtC,EAAMC,cAAND,EAER,OACE,cAAC0E,GAAD,CAAiB5K,UAAU,UAA3B,SACE,sBAAKA,UAAU,QAAf,UACE,cAACmN,GAAD,CACEC,MAAOlH,EAAE,QACTxG,QAAS,kBAAM6G,EAASkC,GAAa,UACrC4E,KAAK,OACL9E,SAAUA,EAJZ,SAME,qBAAKkF,QAAQ,cAAcjI,MAAM,KAAKC,OAAO,KAA7C,SACE,sBAAMuC,EAxBH,uSA4BP,cAACsF,GAAD,CACExF,KAAK,YACLuF,KAAK,SACL9E,SAAUA,EACV6E,MAAOlH,EAAE,kBACTxG,QAAS,kBAAM6G,EAASkC,GAAa,cAGvC,cAAC6E,GAAD,CACExF,KAAK,YACLuF,KAAK,SACL9E,SAAUA,EACV6E,MAAOlH,EAAE,oBACTxG,QAAS,kBAAM6G,EAASkC,GAAa,cAGvC,cAAC0E,GAAD,CACEC,MAAOlH,EAAE,cACTxG,QAAS,kBAAM6G,EAASkC,GAAa,YACrC4E,KAAK,SACL9E,SAAUA,EAJZ,SAME,qBAAK/C,MAAO0H,GAAezH,OAAQyH,GAAnC,SACE,wBACEjN,GAAIiN,KACJhN,GAAIgN,KACJ/M,EAAG+M,KACHQ,KAAK,aAKX,cAACJ,GAAD,CACEF,MAAOlH,EAAE,oBACTxG,QAAS,kBAAM6G,EAASkC,GAAa,WACrCX,KA9DO,mBA+DPuF,KAAK,QACL9E,SAAUA,IAGZ,cAAC+E,GAAD,CACEF,MAAOlH,EAAE,UACTxG,QAAS,kBAAM6G,EAAS1C,MACxBiE,KArEO,qCAsEPuF,KAAK,SACL9E,SAAUxH,EAAS,SAAW,KAGhC,cAACuM,GAAD,CACEF,MAAOlH,EAAE,QACTxG,QAAS,kBAAM6G,EAASoH,kBAAeC,SACvC9F,KA3ER,6JA4EQuF,KAAK,OACL9E,SAAU,KAEZ,cAAC+E,GAAD,CACEF,MAAOlH,EAAE,QACTxG,QAAS,kBAAM6G,EAASoH,kBAAeE,SACvC/F,KAhFR,gKAiFQuF,KAAK,OACL9E,SAAU,UCjGpB,IAAMuF,GAMG,QAIHC,GAAsC,CAC1CC,KAVM,OAWNC,KAVQ,SAWRC,KAVO,SAWPC,KAVO,SAWPC,KAVO,QAWPC,KAAMP,IAMO,SAASQ,KACtB,IAAIC,EACEhI,EAAWlG,IACX6E,EAAU3E,EAAe0E,GACzBjE,EAAST,EAAe+E,GACxB9F,EAAWe,EAAe8E,GAC1BmJ,EAAYjO,EAAeiI,IAC3BC,EAAe,SAACF,GAAD,OACnBhC,EAASkI,GAAclG,KACzB,EAAsDnC,mBAAS,MAA/D,mBAAOsI,EAAP,KAA4BC,EAA5B,KACA,EAAmDvI,mBAAS,MAA5D,mBAAOwI,EAAP,KAA2BC,EAA3B,KACA,EAA0BzI,mBAAS,eAAnC,mBAAOyF,EAAP,KAAciD,EAAd,KACA,EAAsC1I,mBAAS,IAA/C,mBAAO2I,EAAP,KAAoBC,EAApB,KAsBA,SAASC,EACPnM,EACAoM,GAEA,IAAIC,EAAKZ,EAAIa,iBACbD,EAAGtP,EAAIiD,EAAEuM,QACTF,EAAGrP,EAAIgD,EAAEwM,QACT,IAAMC,EAAWJ,EAAGK,gBAAgBjB,EAAIkB,eAAeC,WAUvD,MATqB,CACnB3P,KAAMmP,EACNjO,YAAa,KACbC,IAAKgO,IAActN,EAAmB2N,EAASzP,EAAIyP,EAAS1P,EAC5DsB,OAAQ,EACRC,gBAAiB,EACjBC,UAAW,EACXC,MAAO,IAaX,SAASqO,IACPX,ECjHW,SAAexP,EAAoBsB,GAChD,IAAKtB,EAAS2B,OACZ,MAAO,GAKTL,GADwB,GAIxB,IAAM8O,EAAQpQ,EAAS,GAQjBqQ,EAPNrQ,EAAWA,EAASG,KAAI,SAACwC,GACvB,IAAIuF,EAAiB,eAAQvF,GAG7B,OAFAuF,EAAU7H,GAAKsC,EAAOtC,EAAI+P,EAAM/P,GAAKiB,EACrC4G,EAAU5H,GAAKqC,EAAOrC,EAAI8P,EAAM9P,IAAMgB,EAC/B4G,KAITlI,EAAQ,YAAOA,GACfuD,QAAQC,IAAI,oBAEZ,IAAMiD,EAAazG,EAASwH,QAC5B,IAAKf,EACH,MAAO,GAGT,IAAI6J,EAAuB,GAEvBC,EAAyB,KAsC7B,OArCAvQ,EAAS0C,SAAQ,SAACC,EAAQvC,GAExB,GADAA,GAAK,EACe,YAAhBuC,EAAOpC,KAIT,OAFAgQ,EAAU5N,OACV2N,EAAW7L,KAAX,mBAA4BrE,EAA5B,MAIEmQ,GACa,IAAIC,KACjBH,EAAYjQ,EAAI,GAAGC,EACnBgQ,EAAYjQ,EAAI,GAAGE,EACnB+P,EAAYjQ,EAAI,GAAGC,EACnBgQ,EAAYjQ,EAAI,GAAGE,EACnBqC,EAAOtC,EACPsC,EAAOrC,GAIFmQ,OADO,IACO/N,SAAQ,SAACgO,GAC5BJ,EAAW7L,KAAX,cAAuBiM,EAAKrQ,EAA5B,aAAkCqQ,EAAKpQ,EAAvC,aAA6CF,EAA7C,cAEFmQ,EAAU,MAGVD,EAAW7L,KAAX,cAAuB9B,EAAOtC,EAA9B,aAAoCsC,EAAOrC,EAA3C,aAAiDF,EAAjD,SAIW,cAhEH,GAgEG,iBACXqG,EAAWpG,EADA,aACMoG,EAAWnG,EADjB,sBA/DJ,EA+DI,aA9DJ,IA8DI,aAGfgQ,EAAW/H,KAAK,MAHD,iBAhEH,GAgEG,QDsDXnJ,CAAMsG,EAAQnE,OAASuG,GAAa9H,GAAYA,EAAU0F,EAAQpE,QA+JtE,IAAMqP,EAA2C,CAC/CC,KAAM,aACNC,OAnNF,SAAmBvN,GACjB,GAAIA,EAAEwN,OACJ/J,EAASzC,SADX,CAIA,IAAIqL,EAAKZ,EAAIa,iBACbD,EAAGtP,EAAIiD,EAAEuM,QACTF,EAAGrP,EAAIgD,EAAEwM,QACT,IAAMC,EAAWJ,EAAGK,gBAAgBjB,EAAIkB,eAAeC,WACvDnJ,EACEvC,EAAU,CACR1B,QAAS,KACTF,QAAS,KACTvC,EAAG0P,EAAS1P,EACZC,EAAGyP,EAASzP,EACZC,KAAM,WAqMVwQ,OA5KF,SAAmBzN,GACjByD,EAASlC,EAAS4K,EAAYnM,EAAGlB,MA4KjC4O,OAzKF,SAAmB1N,GACjByD,EAASlC,EAAS4K,EAAYnM,EAAGT,OA2K7BoO,EAAe,IAEfhD,EAAO,cAAUgD,EAAV,YADS,KAEtB,OACE,sBACEzQ,UAAU,YACVkL,MAAO,CAAEwF,OAAQ,mBAFnB,UAKE,qBAAK1Q,UAAU,WAAf,SACE,cAAC4L,GAAD,CACEC,MAAOA,EACPC,qBAAsBgD,EACtB/C,YAhDR,WACEhJ,QAAQC,IAAI,kBACZuD,EAASzC,KACTyC,EAASnC,KACTqE,EAAa,QACbkG,EAAuB,MACvBE,EAAqB,MACrBtI,EAAS/C,EA5MS,IA6MlB+C,EAAShD,EAAQ,MAyCXyI,aAtCR,WACE2E,GAAc7G,QAsCRmC,aAnCR,SAA0BpL,GACX,KAATA,EAGOA,IAASqE,EAAQrE,OAG5B8P,GAActH,KAAKxI,GACnB4H,EAAa,QACbkG,EAAuB,MACvBE,EAAqB,OARnBtI,EAAShD,EAAQ,MAkCb3E,MAAOmQ,EACP7C,cAAeyD,MAGnB,cAACnC,GAAD,IACA,sBACEoD,GAAG,MACHC,IAAK,SAACA,GACJtC,EAAMsC,GAERpD,QAASA,EACTzN,UAAU,iBACVkL,MAAO,CAAEwF,OAAQ,iBAAkBjL,OAAQ,SAC3C/F,QAASyQ,EAAe3B,GACxBsC,UAAW,WACTnC,EAAuB,MACvBE,EAAqB,MACrBtI,EAASxB,MAEXgM,YAjJN,SAAoBjO,GAClB,GAA4B,OAAxB4L,GAAuD,OAAvBE,EAApC,CAIA,IAAIO,EAAKZ,EAAIa,iBACbD,EAAGtP,EAAIiD,EAAEuM,QACTF,EAAGrP,EAAIgD,EAAEwM,QACT,IAAMC,EAAWJ,EAAGK,gBAAgBjB,EAAIkB,eAAeC,WAEvD,GAA4B,OAAxBhB,EAA8B,CAChC,IAGIxH,EAAW,IACX8J,EAA2B,KAC3BC,EAAkB,KAEtBjQ,EAAOkB,SAAQ,SAACP,EAAc/B,GAC5B,GAAI+B,EAAM5B,OAAS6B,EAAkB,CACnC,IAAMsP,EAAcpP,KAAKqF,IAAIxF,EAAMT,IAAMqO,EAASzP,GAC9CoR,EAAchK,GAAYgK,EAVZ,KAWhBF,EAAarP,EACbsP,EAAkBrR,EAClBsH,EAAWgK,OAIbF,IACFzB,EAASzP,EAAIkR,EAAU,KAIzB9J,EAAW,IACX,IAAIiK,EAAa,KACbC,GAAmB,EACvBpQ,EAAOkB,SAAQ,SAACP,EAAO/B,GACrB,GAAI+B,EAAM5B,OAASsC,EAAgB,CACjC,IAAM6O,EAAcpP,KAAKqF,IAAIxF,EAAMT,IAAMqO,EAAS1P,GAC9CqR,EAAchK,GAAYgK,EA5BZ,KA6BhBC,EAAaxP,EACbyP,EAAkBxR,EAClBsH,EAAWgK,OAIbC,IACF5B,EAAS1P,EAAIsR,EAAU,KAGzB,IAAMhP,EAAS,CACbpC,KAAMP,EAASkP,GAAqB3O,KACpCqC,QAAS6O,EACT3O,QAAS8O,EACTvR,EAAG0P,EAAS1P,EACZC,EAAGyP,EAASzP,GAEdyG,EACErC,EAAe,CACb/B,SACAgC,MAAOuK,UAGN,GAA2B,OAAvBE,EAA6B,CACtC,IAAM1N,EAAM,CACVrB,EAAG0P,EAAS1P,EACZC,EAAGyP,EAASzP,EACZqE,MAAOyK,GAETrI,EAAS9B,EAAYvD,SAErB6B,QAAQsO,MAAM,WA2EZC,SAAU,EACVC,WAvMN,SAAwBzO,GACtB,IAAMF,EAAME,EAAE0O,KACd,GAAY,SAAR5O,EACEE,EAAE2O,WACJlL,EAASzC,KACTyC,EAASnC,MAEXqE,EAAa,aACR,GAAY,SAAR7F,EACT+M,IACAlH,EAAa,aACR,GAAY,SAAR7F,EAAgB,CACzB,IAAI8O,EAAgB,YAAOlS,GAC3BkS,EAAiBC,UACjBpL,EAASxC,EAAY2N,IACrBjJ,EAAa,aACR,GAAY,SAAR7F,EAAgB,CACzB,GAAIpD,EAAS2B,OAAQ,CACnB,IAAMyQ,EAAQpS,EAAS,GAAGK,EACtBgS,EAAoBrS,EAASG,KAAI,SAACwC,GACpC,IAAMuF,EAAiB,eAAQvF,GAE/B,OADAuF,EAAU7H,EAAI+R,GAASzP,EAAOtC,EAAI+R,GAC3BlK,KAGTnB,EAASxC,EAAY8N,IAEvBpJ,EAAa,YACI,SAAR7F,EACT2D,EAAS1C,KAET4E,EAAasF,GAAUnL,KAwJvB,UAkBE,uBAAOkP,KAAMjG,EAAOpG,OAAO,SAC3B,cAACkC,GAAD,CAAMnI,SAAUA,EAAUuB,OAAQmE,EAAQnE,SAC1C,cAAC6F,EAAD,CACEpB,MAAOiL,EACPhL,OA1Cc,IA2Cd3E,MAAOoE,EAAQpE,QAEjB,cAACnC,EAAD,CACE6G,MAAOiL,EACPhL,OA/Cc,IAgDdhG,YAAaoP,IAEf,cAACtP,EAAD,CACEC,SAAUA,EACVC,YAAakP,EACbjP,QArLR,SAA2BE,GACzB,GAAI4O,IAAcV,GAAlB,CAGA,IAAI3L,EAAS3C,EAASI,GAClB8H,EAAiB,eAAQvF,GAE7BuF,EAAU3H,KAAO,UAEjB2H,EAAU7H,EAAIsC,EAAOtC,EADP,GAEd6H,EAAU5H,EAAIqC,EAAOrC,EAFP,GAId,IAAIiS,EAAU,YAAOvS,GACrBuS,EAAWC,OAAOpS,EAAG,EAAG8H,GACxBnB,EAASxC,EAAYgO,cElKVE,OAPf,WAIE,OAAO,cAAC3D,GAAD,KCGW4D,QACW,cAA7B3I,OAAO4I,SAASC,UAEe,UAA7B7I,OAAO4I,SAASC,UAEhB7I,OAAO4I,SAASC,SAASC,MACvB,2DCVNC,SACE,cAAC,IAAMC,WAAP,UACE,cAAC,IAAD,CAAU5J,MAAOA,GAAjB,SACE,cAAC,GAAD,QAGJ6J,SAASC,eAAe,SDmHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.75a7af19.chunk.js","sourcesContent":["import i18n from \"i18next\";\nimport LanguageDetector from \"i18next-browser-languagedetector\";\nimport { initReactI18next } from \"react-i18next\";\n\nexport const resources = {\n  en: {\n    translation: {\n      \"New pattern\": \"New pattern\",\n      Patterns: \"Patterns\",\n      \"New name\": \"New name\",\n      Save: \"save\",\n      \"Background image url\": \"Background image url\",\n      \"Background image\": \"Background image\",\n      Scale: \"Scale\",\n      Guides: \"Guides\",\n      gcode: \"gcode\",\n      Generate: \"Generate\",\n      //toolbox\n      Move: \"Move\",\n      \"Vertical guide\": \"Vertical guide\",\n      \"Horizontal guide\": \"Horizontal guide\",\n      \"Add vertex\": \"Add vertex\",\n      \"Convert to curve\": \"convert to curve\",\n      Mirror: \"Mirror\",\n      Undo: \"Undo\",\n      Redo: \"Redo\",\n    },\n  },\n  es: {\n    translation: {\n      \"New pattern\": \"Nuevo patrón\",\n      Patterns: \"Patrones\",\n      \"New name\": \"Nuevo nombre\",\n      Save: \"Guardar\",\n      \"Background image url\": \"url para imagen de fondo\",\n      \"Background image\": \"Imagen de fondo\",\n      Scale: \"Escala\",\n      Guides: \"Guías\",\n      gcode: \"gcode\",\n      Generate: \"Generar\",\n      //toolbox\n      Move: \"Mover\",\n      \"Vertical guide\": \"Guía vertical\",\n      \"Horizontal guide\": \"Guía horizontal\",\n      \"Add vertex\": \"Agregar vértice\",\n      \"Convert to curve\": \"Convertir a curva\",\n      Mirror: \"Reflejar\",\n      Undo: \"Deshacer\",\n      Redo: \"Rehacer\",\n    },\n  },\n};\n\ni18n\n  .use(LanguageDetector)\n  .use(initReactI18next)\n  .init({\n    resources,\n    interpolation: {\n      escapeValue: false, // react already escapes\n    },\n    detection: {\n      order: [\"localStorage\", \"navigator\", \"htmlTag\"],\n    },\n  });\n","import { Vertex } from \"./points\";\n\ninterface HandlesProps {\n  vertices: Vertex[];\n  onMouseDown: Function;\n  onClick: Function;\n}\n\nconst HANDLE_RADIUS = 8;\n\nexport default function Handles({\n  vertices,\n  onMouseDown,\n  onClick,\n}: HandlesProps) {\n  return (\n    <>\n      {vertices.map(({ x, y, type }, i) => (\n        <g\n          key={i}\n          className=\"handle\"\n          onMouseDown={() => onMouseDown(i)}\n          onClick={() => onClick(i)}\n        >\n          <circle\n            cx={x}\n            cy={y}\n            className={`${i ? type : \"start\"}`}\n            r={HANDLE_RADIUS}\n          />\n          <text x={x - HANDLE_RADIUS / 2} y={y + HANDLE_RADIUS / 2}>\n            {i}\n          </text>\n        </g>\n      ))}\n    </>\n  );\n}\n","import { TypedUseSelectorHook, useDispatch, useSelector } from \"react-redux\";\nimport type { RootState, AppDispatch } from \"./store\";\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { create, all } from \"mathjs\";\nimport { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport type { RootState } from \"../app/store\";\nimport { Vertex } from \"./points\";\nimport { Guide, GUIDE_HORIZONTAL, GUIDE_VERTICAL } from \"./Guides\";\n\nconst math = create(all);\n\ninterface Parameters {\n  name: string;\n  parameters: { [key: string]: number };\n}\n\ninterface PatternState {\n  name: string;\n  vertices: Vertex[];\n  guides: Guide[];\n  scale: number;\n  mirror: boolean;\n  parameters: Parameters[];\n}\n\nconst initialState: PatternState = {\n  name: \"\",\n  scale: 1,\n  mirror: false,\n  vertices: [],\n  guides: [\n    //Default origin guides. used by other guides to set lengths.\n    {\n      type: \"h\",\n      originIndex: null,\n      //TODO: calculate svg height and set it as default pos\n      pos: 500,\n      length: 500,\n      lengthExpresion: 500,\n      direction: 1,\n      label: \"\",\n    },\n    {\n      type: \"v\",\n      originIndex: null,\n      pos: 30,\n      length: 30,\n      lengthExpresion: 30,\n      direction: 1,\n      label: \"\",\n    },\n  ],\n  parameters: [\n    {\n      name: \"body\",\n      parameters: {\n        Waist: 94,\n        Shoulder: 20,\n      },\n    },\n    {\n      name: \"customization\",\n      parameters: {\n        \"Waist extra\": 1,\n      },\n    },\n  ],\n};\n\nconst HORIZONTAL_GUIDE_INDEX = 0;\nconst VERTICAL_GUIDE_INDEX = 1;\nconst NON_ORIGINS_START_INDEX = 2;\n\ninterface GuidePos {\n  x: number;\n  y: number;\n  index: number;\n}\n\ninterface GuideLength {\n  length: string;\n  index: number;\n}\n\ninterface vertexValue {\n  vertex: Vertex;\n  index: number;\n}\n\ninterface ParameterValue {\n  index: number;\n  name: string;\n  value: number;\n}\n\nfunction calculateLength(guide: Guide, guides: Guide[], scale: number) {\n  let length = 0;\n  if (guide.type === GUIDE_HORIZONTAL) {\n    const originGuide = guides[HORIZONTAL_GUIDE_INDEX];\n    length = (originGuide.pos - guide.pos) * scale;\n  } else {\n    const originGuide = guides[VERTICAL_GUIDE_INDEX];\n    length = (guide.pos - originGuide.pos) * scale;\n  }\n  //TODO: round to int and adjust positions?\n  length = Math.round(length * 100) / 100;\n  return length;\n}\n\nfunction updateAnchoredVertices(\n  vertices: Vertex[],\n  guide: Guide,\n  guideIndex: number\n) {\n  vertices.forEach((vertex) => {\n    if (guide.type === GUIDE_HORIZONTAL && vertex.anchorY === guideIndex) {\n      vertex.y = guide.pos;\n    } else if (guide.type === GUIDE_VERTICAL && vertex.anchorX === guideIndex) {\n      vertex.x = guide.pos;\n    }\n  });\n}\n\nfunction computeGuideLength(\n  lengthExpresion: number | string,\n  guideIndex: number,\n  state: PatternState\n) {\n  //x or y origin\n  if (guideIndex < NON_ORIGINS_START_INDEX) {\n    return;\n  }\n\n  let guide = state.guides[guideIndex];\n  guide.lengthExpresion = lengthExpresion;\n\n  let guideLength = 0;\n  try {\n    //TODO: use dot notation or something to prevent overwriting duplicated names.\n    let scope: { [key: string]: number } = {};\n    state.parameters.forEach((parameter) => {\n      for (const key in parameter.parameters) {\n        scope[key] = parameter.parameters[key];\n      }\n    });\n    state.guides.forEach((guide) => {\n      if (guide.label) {\n        scope[guide.label] = guide.length;\n      }\n    });\n\n    guideLength = math.evaluate(`${lengthExpresion}`, scope);\n  } catch (e) {\n    //TODO: report it or give feedback somehow.\n    console.log(e);\n    return;\n  }\n  if (typeof guideLength !== \"number\") {\n    return;\n  }\n\n  guide.length = guideLength;\n  if (guide.type === GUIDE_HORIZONTAL) {\n    const originGuide = state.guides[HORIZONTAL_GUIDE_INDEX];\n    guide.pos = originGuide.pos - guide.length / state.scale;\n  } else {\n    const originGuide = state.guides[VERTICAL_GUIDE_INDEX];\n    guide.pos = originGuide.pos + guide.length / state.scale;\n  }\n\n  updateAnchoredVertices(state.vertices, guide, guideIndex);\n}\n\nexport const patternSlice = createSlice({\n  name: \"pattern\",\n  initialState,\n  reducers: {\n    setPattern: (state, action: PayloadAction<PatternState>) => {\n      console.log(\"loading state\");\n      const { name, scale, mirror, vertices, guides, parameters } =\n        action.payload;\n      state.name = name;\n      state.scale = scale;\n      state.mirror = mirror;\n      state.vertices = vertices;\n      state.guides = guides;\n      state.parameters = parameters;\n    },\n    setName: (state, action: PayloadAction<string>) => {\n      state.name = action.payload;\n    },\n    setScale: (state, action: PayloadAction<number>) => {\n      const oldScale = state.scale;\n      state.scale = action.payload;\n      const scaleFactor = state.scale / oldScale;\n      state.guides.forEach((guide, i) => {\n        const oldLength = guide.length;\n        guide.length *= scaleFactor;\n        guide.length = Math.round(guide.length * 100) / 100;\n        if (guide.lengthExpresion === oldLength) {\n          guide.lengthExpresion = guide.length;\n        }\n        state.guides.forEach((guide, i) => {\n          computeGuideLength(guide.lengthExpresion, i, state);\n        });\n      });\n    },\n    setMirror: (state, action: PayloadAction<boolean>) => {\n      state.mirror = action.payload;\n    },\n    toggleMirror: (state, action: PayloadAction<void>) => {\n      state.mirror = !state.mirror;\n    },\n    clearVertices: (state, action: PayloadAction<void>) => {\n      state.vertices = [];\n    },\n    setVertices: (state, action: PayloadAction<Vertex[]>) => {\n      state.vertices = action.payload;\n    },\n    addVertex: (state, action: PayloadAction<Vertex>) => {\n      state.vertices.push(action.payload);\n    },\n    setVertexValue: (state, action: PayloadAction<vertexValue>) => {\n      state.vertices[action.payload.index] = action.payload.vertex;\n    },\n    clearGuides: (state, action: PayloadAction<void>) => {\n      state.guides = [...initialState.guides];\n    },\n    addGuide: (state, action: PayloadAction<Guide>) => {\n      const lastIndex = state.guides.push(action.payload) - 1;\n      let lastGuide = state.guides[lastIndex];\n      lastGuide.length = calculateLength(lastGuide, state.guides, state.scale);\n      lastGuide.lengthExpresion = lastGuide.length;\n    },\n    setGuideLabel: (\n      state,\n      action: PayloadAction<{ label: string; index: number }>\n    ) => {\n      state.guides[action.payload.index].label = action.payload.label;\n    },\n    setGuidePos: (state, action: PayloadAction<GuidePos>) => {\n      const guideIndex = action.payload.index;\n      let guide = state.guides[guideIndex];\n      const { x, y } = action.payload;\n      guide.pos = guide.type === GUIDE_HORIZONTAL ? y : x;\n      if (guideIndex < NON_ORIGINS_START_INDEX) {\n        //x or y origins\n        guide.length = 0;\n\n        //update all guides anchored.\n        for (\n          let i = NON_ORIGINS_START_INDEX, len = state.guides.length;\n          i < len;\n          i++\n        ) {\n          let nonOriginGuide = state.guides[i];\n          if (nonOriginGuide.type === guide.type) {\n            if (nonOriginGuide.length === nonOriginGuide.lengthExpresion) {\n              nonOriginGuide.length = calculateLength(\n                nonOriginGuide,\n                state.guides,\n                state.scale\n              );\n              nonOriginGuide.lengthExpresion = nonOriginGuide.length;\n            } else {\n              computeGuideLength(nonOriginGuide.lengthExpresion, i, state);\n            }\n          }\n        }\n      } else {\n        guide.length = calculateLength(guide, state.guides, state.scale);\n        guide.lengthExpresion = guide.length;\n      }\n\n      updateAnchoredVertices(state.vertices, guide, guideIndex);\n    },\n    setGuideLength: (state, action: PayloadAction<GuideLength>) => {\n      const guideIndex = action.payload.index;\n      computeGuideLength(action.payload.length, guideIndex, state);\n    },\n    setParameterValue: (state, action: PayloadAction<ParameterValue>) => {\n      state.parameters[action.payload.index].parameters[action.payload.name] =\n        action.payload.value;\n      state.guides.forEach((guide, i) => {\n        computeGuideLength(guide.lengthExpresion, i, state);\n      });\n    },\n    finishDragging: (state, action: PayloadAction<void>) => {\n      //dummy reducer to have an undoable action for the entire dragging movement.\n    },\n  },\n});\n\nexport const {\n  setName,\n  setScale,\n  setMirror,\n  toggleMirror,\n  clearVertices,\n  setVertices,\n  addVertex,\n  setVertexValue,\n  clearGuides,\n  addGuide,\n  setGuideLabel,\n  setGuidePos,\n  setGuideLength,\n  setParameterValue,\n  finishDragging,\n} = patternSlice.actions;\nexport const selectPattern = (state: RootState) => state.pattern.present;\nexport const selectMirror = (state: RootState) => state.pattern.present.mirror;\nexport const selectVertices = (state: RootState) =>\n  state.pattern.present.vertices;\nexport const selectGuides = (state: RootState) => state.pattern.present.guides;\nexport const selectParameters = (state: RootState) =>\n  state.pattern.present.parameters;\nexport default patternSlice.reducer;\n","import { useAppSelector } from \"../app/hooks\";\n//FIXME: circular dependency prevents importing constants\nimport { selectGuides } from \"./patternSlice\";\n\nexport type GuideOld = [number, \"hLine\" | \"vLine\"];\n\nexport const GUIDE_HORIZONTAL = \"h\";\nexport const GUIDE_VERTICAL = \"v\";\n\nexport interface Guide {\n  type: \"h\" | \"v\";\n  originIndex: number | null;\n  pos: number;\n  length: number;\n  lengthExpresion: number | string;\n  direction: 1 | -1;\n  label: string;\n}\n\nexport interface GuidesProps {\n  width: number;\n  height: number;\n  onMouseDown: Function;\n}\n\nexport function Guides({ width, height, onMouseDown }: GuidesProps) {\n  const guides = useAppSelector(selectGuides);\n  return (\n    <>\n      {guides.map(({ pos, type }, i) => {\n        let points = {};\n        if (type === GUIDE_HORIZONTAL) {\n          points = {\n            x1: 0,\n            x2: width,\n            y1: pos,\n            y2: pos,\n          };\n        } else {\n          points = {\n            x1: pos,\n            x2: pos,\n            y1: 0,\n            y2: height,\n          };\n        }\n\n        return (\n          <g className=\"guide\" onMouseDown={() => onMouseDown(i)} key={i}>\n            <line {...points} className=\"hover\" />\n            <line {...points} />\n          </g>\n        );\n      })}\n    </>\n  );\n}\n","import { useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useAppSelector, useAppDispatch } from \"../app/hooks\";\nimport { selectGuides, setGuideLabel, setGuideLength } from \"./patternSlice\";\nimport { GUIDE_HORIZONTAL } from \"./Guides\";\n\nconst TRIANGLE_LENGTH = 3;\ninterface GuideMeasurementsProps {\n  width: number;\n  height: number;\n  scale: number;\n}\n\ninterface InputFieldProps {\n  x: number;\n  y: number;\n  children: React.ReactNode;\n  index: number;\n  firstPoint: number;\n  scale: number;\n}\n\nfunction InputField({\n  x,\n  y,\n  index,\n  firstPoint,\n  scale,\n  children,\n}: InputFieldProps) {\n  const { t } = useTranslation();\n  const [visible, setVisible] = useState(false);\n  const dispatch = useAppDispatch();\n  const guide = useAppSelector(selectGuides)[index];\n\n  return (\n    <g className=\"measurement\" onClick={() => setVisible(!visible)}>\n      {children}\n      {visible ? (\n        <foreignObject width=\"150\" height=\"1.5em\" x={x - 150} y={y - 20}>\n          <input\n            onClick={(e) => e.stopPropagation()}\n            type=\"text\"\n            value={guide.label}\n            placeholder={t(\"label\")}\n            onChange={(e) =>\n              dispatch(setGuideLabel({ label: e.target.value, index }))\n            }\n          />\n        </foreignObject>\n      ) : (\n        <text x={x} y={y}>\n          {guide.label}\n        </text>\n      )}\n      {visible && (\n        <foreignObject width=\"100\" height=\"1.5em\" x={x + 20} y={y - 20}>\n          <input\n            onClick={(e) => e.stopPropagation()}\n            type=\"text\"\n            placeholder={t(\"value\")}\n            value={guide.lengthExpresion}\n            onChange={(e) => {\n              const value = e.target.value;\n              dispatch(setGuideLength({ length: value, index }));\n            }}\n          />\n        </foreignObject>\n      )}\n    </g>\n  );\n}\n\nexport default function GuideMeasurements({\n  width,\n  height,\n  scale,\n}: GuideMeasurementsProps) {\n  const guides = useAppSelector(selectGuides);\n  let hGuides: number[][] = [];\n  let vGuides: number[][] = [];\n  guides.forEach(({ pos, length, type }, i) => {\n    if (type === GUIDE_HORIZONTAL) {\n      hGuides.push([pos, length, i]);\n    } else {\n      vGuides.push([pos, length, i]);\n    }\n  });\n\n  const firstHPoint: number = hGuides.length ? hGuides.shift()![0] : 0;\n  const firstVPoint: number = vGuides.length ? vGuides.shift()![0] : 0;\n\n  return (\n    <>\n      {hGuides.map(([pos, length, guideIndex], i) => {\n        const distance = Math.abs(pos - firstHPoint);\n        const x = (width / (hGuides.length + 1)) * (i + 1);\n        const textY = firstHPoint - distance / 2;\n        const points = {\n          x1: x,\n          x2: x,\n          y1: pos,\n          y2: firstHPoint,\n        };\n        //TODO the measurment should go the other way if the firstPoint is shorter (firstHPoint+distance/2)\n        return (\n          <InputField\n            x={x}\n            y={textY - 5}\n            index={guideIndex}\n            firstPoint={firstVPoint}\n            scale={scale}\n            key={i + \"v\"}\n          >\n            <line {...points} />\n            <polyline\n              points={`${x},${pos} ${x + TRIANGLE_LENGTH},${\n                pos + TRIANGLE_LENGTH\n              } ${x - TRIANGLE_LENGTH},${pos + TRIANGLE_LENGTH} ${x},${pos}`}\n            />\n            <polyline\n              points={`${x},${firstHPoint} ${x + TRIANGLE_LENGTH},${\n                firstHPoint - TRIANGLE_LENGTH\n              } ${x - TRIANGLE_LENGTH},${\n                firstHPoint - TRIANGLE_LENGTH\n              } ${x},${firstHPoint}`}\n            />\n            <text x={x} y={textY + 15}>\n              {length}\n            </text>\n          </InputField>\n        );\n      })}\n\n      {vGuides.map(([pos, length, guideIndex], i) => {\n        const distance = Math.abs(pos - firstVPoint);\n        const y = (height / (vGuides.length + 1)) * (i + 1);\n        const textX = firstVPoint + distance / 2;\n        const points = {\n          x1: firstVPoint,\n          x2: pos,\n          y1: y,\n          y2: y,\n        };\n        //TODO the measurment should go the other way if the firstPoint is shorter (firstHPoint+distance/2)\n        return (\n          <InputField\n            x={textX}\n            y={y - 5}\n            index={guideIndex}\n            firstPoint={firstVPoint}\n            scale={scale}\n            key={i + \"v\"}\n          >\n            <line {...points} />\n            <polyline\n              points={`${firstVPoint},${y} ${firstVPoint + TRIANGLE_LENGTH},${\n                y + TRIANGLE_LENGTH\n              } ${firstVPoint + TRIANGLE_LENGTH},${\n                y - TRIANGLE_LENGTH\n              } ${firstVPoint},${y}`}\n            />\n            <polyline\n              points={`${pos},${y} ${pos - TRIANGLE_LENGTH},${\n                y - TRIANGLE_LENGTH\n              } ${pos - TRIANGLE_LENGTH},${y + TRIANGLE_LENGTH} ${pos},${y}`}\n            />\n            <text y={y + 15} x={textX}>\n              {length}\n            </text>\n          </InputField>\n        );\n      })}\n    </>\n  );\n}\n","export interface Vertex {\n  anchorX: number | null;\n  anchorY: number | null;\n  type: \"end\" | \"control\";\n  x: number;\n  y: number;\n}\n\nexport function mirrorPoints(vertices: Array<Vertex>) {\n  if (vertices.length < 3) {\n    return vertices;\n  }\n  const stopIndex = vertices.length - 1;\n  let newVertices: Array<Vertex> = [];\n  vertices.forEach((vertex, i) => {\n    if (i === stopIndex) {\n      return;\n    }\n    newVertices.push(vertex);\n  });\n\n  const yAxis = vertices[stopIndex].x;\n  const delta = yAxis * 2;\n  for (let i = stopIndex; i >= 0; i--) {\n    const vertex = vertices[i];\n    const newVertex: Vertex = { ...vertex };\n    newVertex.x = delta - vertex.x;\n    newVertices.push(newVertex);\n  }\n  return newVertices;\n}\n\nexport default mirrorPoints;\n","import { Vertex, mirrorPoints } from \"./points\";\n\ninterface PathProps {\n  vertices: Vertex[];\n  mirror: boolean;\n}\n\nexport default function Path({ vertices, mirror }: PathProps) {\n  if (!vertices.length) {\n    return null;\n  }\n\n  vertices = mirror ? mirrorPoints(vertices) : vertices;\n\n  let spline = false;\n  const commands = vertices.map((vertex, i) => {\n    const { x, y } = vertex;\n    if (vertex.type === \"control\") {\n      spline = true;\n      return `Q ${x},${y}`;\n    } else {\n      if (spline) {\n        spline = false;\n        return ` ${x}, ${y}`;\n      }\n      return `L ${x}, ${y}`;\n    }\n  });\n\n  const path =\n    `M ${vertices[0].x}, ${vertices[0].y}\\n` + commands.join(\"\\n\") + \" Z\";\n\n  return (\n    <path\n      className=\"path\"\n      d={path}\n      stroke=\"LightSkyBlue\"\n      strokeWidth=\"1\"\n      strokeOpacity=\"1\"\n      opacity=\"1\"\n      fillOpacity=\"0\"\n    />\n  );\n}\n","import { createSlice, PayloadAction } from \"@reduxjs/toolkit\";\nimport type { RootState } from \"../app/store\";\n\nexport type ToolState =\n  | \"move\"\n  | \"hguide\"\n  | \"vguide\"\n  | \"scale\"\n  | \"handle\"\n  | \"curve\";\n\nconst initialState = {\n  toolMode: \"move\",\n};\n\nexport const toolSlice = createSlice({\n  name: \"tools\",\n  initialState,\n  reducers: {\n    selectToolMode: (state, action: PayloadAction<ToolState>) => {\n      state.toolMode = action.payload;\n    },\n    setToolState: (state, action: PayloadAction<ToolState>) => {\n      state.toolMode = action.payload;\n    },\n  },\n});\n\nexport const { setToolState } = toolSlice.actions;\nexport const selectToolMode = (state: RootState) => state.toolbox.toolMode;\nexport default toolSlice.reducer;\n","import { configureStore } from \"@reduxjs/toolkit\";\nimport patternReducer from \"../editor/patternSlice\";\nimport toolsReducer from \"../editor/toolsSlice\";\nimport undoable, { excludeAction } from \"redux-undo\";\n\nexport const store = configureStore({\n  reducer: {\n    pattern: undoable(patternReducer, {\n      filter: excludeAction([\"pattern/setGuidePos\", \"pattern/setVertexValue\"]),\n    }),\n    toolbox: toolsReducer,\n  },\n});\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n","import { store } from \"../app/store\";\nimport sample1 from \"./front.json\";\nimport sample2 from \"./back.json\";\n\nconst PATTERN_NAME_PREFIX = \"PATTERN:\";\n\nfunction load(name: string) {\n  console.log(\"loading...\");\n  const sample1Label = \"tank top - back - sample\";\n  if (name === sample1Label) {\n    store.dispatch({ type: \"pattern/setPattern\", payload: sample1 });\n    return;\n  }\n  const sample2Label = \"tank top - front - sample\";\n  if (name === sample2Label) {\n    store.dispatch({ type: \"pattern/setPattern\", payload: sample2 });\n    return;\n  }\n\n  const patternString = window.localStorage.getItem(PATTERN_NAME_PREFIX + name);\n  if (!patternString) {\n    console.log(`pattern: ${name} not found`, name);\n    return;\n  }\n  const pattern = JSON.parse(patternString);\n  console.log(pattern);\n  store.dispatch({ type: \"pattern/setPattern\", payload: pattern });\n}\n\nfunction save() {\n  const pattern = store.getState().pattern.present;\n  if (pattern.name === \"\") {\n    return;\n  }\n  console.log(\"saving\", pattern);\n  window.localStorage.setItem(\n    PATTERN_NAME_PREFIX + pattern.name,\n    JSON.stringify(pattern)\n  );\n}\n\nconst functions = {\n  load,\n  save,\n};\nexport default functions;\n","import { useTranslation } from \"react-i18next\";\n\ninterface BackgroundInputProps {\n  onChange: (filename: string, image: string) => void;\n}\n\nexport default function BackgroundInput({ onChange }: BackgroundInputProps) {\n  const { t } = useTranslation();\n  return (\n    <div>\n      <div>{t(\"Background image\")}</div>\n      <div>\n        <input\n          type=\"file\"\n          accept=\"image/*\"\n          onChange={(e) => {\n            const reader = new FileReader();\n            const file = e.target.files![0];\n            reader.onload = (e) =>\n              onChange(file.name, e.target!.result as string);\n            reader.readAsDataURL(e.target.files![0]);\n          }}\n        />\n      </div>\n    </div>\n  );\n}\n","import { useState, useLayoutEffect } from \"react\";\n\ninterface ControlsWrapperProps {\n  className?: string;\n  children: React.ReactNode;\n}\n\nconst QUERY_STRING = \"screen and (max-device-width: 800px)\";\nexport function ControlsWrapper({ className, children }: ControlsWrapperProps) {\n  const [open, setOpen] = useState(true);\n  const matches = window.matchMedia(QUERY_STRING).matches;\n  useLayoutEffect(() => {\n    //This doesn't update after the first render.\n    const mediaQuery = window.matchMedia(QUERY_STRING).matches;\n    if (mediaQuery) {\n      setOpen(false);\n    }\n  }, [matches]);\n  return (\n    <div className={className}>\n      <button className=\"toggle-controls\" onClick={(e) => setOpen(!open)}>\n        {open ? \"-\" : \"o\"}\n      </button>\n      <div style={{ display: open ? \"\" : \"none\" }}>{children}</div>\n    </div>\n  );\n}\n","import { useAppSelector, useAppDispatch } from \"../app/hooks\";\nimport { setParameterValue, selectParameters } from \"./patternSlice\";\n\nexport default function Parameters() {\n  const parametersList = useAppSelector(selectParameters);\n  const dispatch = useAppDispatch();\n\n  const intputFields = parametersList.map(({ name, parameters }, i) => {\n    const fields = [];\n    for (const key in parameters) {\n      fields.push(\n        <div key={key}>\n          <div>{key}</div>\n          <input\n            type=\"number\"\n            value={parameters[key]}\n            onChange={(e) => {\n              const value = e.target.valueAsNumber;\n              if (!Number.isNaN(value)) {\n                dispatch(setParameterValue({ index: i, name: key, value }));\n              }\n            }}\n          />\n        </div>\n      );\n    }\n\n    return (\n      <div key={name}>\n        {i && <div>---</div>}\n        <div style={{ marginBottom: 10 }}>{name}</div>\n        <>{fields}</>\n      </div>\n    );\n  });\n  return <div className=\"parameters\">{intputFields}</div>;\n}\n","import { useState } from \"react\";\nimport i18n from \"i18next\";\nimport { useTranslation } from \"react-i18next\";\nimport { useAppSelector, useAppDispatch } from \"../app/hooks\";\nimport {\n  selectPattern,\n  setName,\n  setScale,\n  setGuideLength,\n  selectGuides,\n} from \"./patternSlice\";\nimport BackgroundInput from \"./BackgroundInput\";\nimport { ControlsWrapper } from \"./ControlsWrapper\";\nimport Parameters from \"./Parameters\";\n\ninterface ControlsProps {\n  image: string;\n  onBackgroundSelected: Function;\n  onNewAction: Function;\n  onSaveAction: Function;\n  onLoadAction: Function;\n  gcode: string;\n  onGcodeAction: Function;\n}\n\nexport default function Controls({\n  image,\n  onBackgroundSelected,\n  onNewAction,\n  onSaveAction,\n  onLoadAction,\n  gcode,\n  onGcodeAction,\n}: ControlsProps) {\n  const { t } = useTranslation();\n  const dispatch = useAppDispatch();\n\n  const guides = useAppSelector(selectGuides);\n  const guideInputs = guides.map(({ lengthExpresion, label }, i) => {\n    if (i < 2) {\n      //Don't display origins\n      return null;\n    }\n    return (\n      <div key={i}>\n        <div>{label || i - 1 /*start counting at 1*/}</div>\n        <div>\n          <input\n            type=\"text\"\n            value={lengthExpresion}\n            onChange={(e) => {\n              const value = {\n                length: e.target.value,\n                index: i,\n              };\n              dispatch(setGuideLength(value));\n            }}\n          />\n        </div>\n      </div>\n    );\n  });\n\n  const [imageFileName, setImageFileName] = useState(\"\");\n  const pattern = useAppSelector(selectPattern);\n\n  const PATTERN_NAME_PREFIX = \"PATTERN:\";\n  const patternNames = [\n    \"\",\n    ...Object.keys(window.localStorage)\n      .filter((name) => {\n        return !name.indexOf(PATTERN_NAME_PREFIX);\n      })\n      .map((name) => name.replace(PATTERN_NAME_PREFIX, \"\")),\n  ];\n\n  //hardcoded samples. Move them to a db later\n  const sample1Label = \"tank top - back - sample\";\n  if (!window.localStorage.getItem(sample1Label)) {\n    patternNames.push(sample1Label);\n  }\n  const sample2Label = \"tank top - front - sample\";\n  if (!window.localStorage.getItem(\"tank top - front - sample\")) {\n    patternNames.push(sample2Label);\n  }\n  ///\n\n  const options = patternNames.map((name) => (\n    <option key={name} value={name}>\n      {name}\n    </option>\n  ));\n\n  return (\n    <ControlsWrapper className=\"controls\">\n      <form>\n        <div>\n          <input\n            type=\"button\"\n            value=\"English\"\n            onClick={() => i18n.changeLanguage(\"en\")}\n          />\n          <input\n            type=\"button\"\n            value=\"Español\"\n            onClick={() => i18n.changeLanguage(\"es\")}\n          />\n        </div>\n\n        <div>\n          <div>\n            <input\n              type=\"button\"\n              value={t(\"New pattern\") as string}\n              onClick={() => onNewAction()}\n            />\n          </div>\n        </div>\n\n        <div>\n          <div>{t(\"Patterns\")}</div>\n          <div>\n            <select onChange={(e) => onLoadAction(e.target.value)}>\n              {options}\n            </select>\n          </div>\n        </div>\n\n        <div>\n          <div>{t(\"New name\")}</div>\n          <div>\n            <input\n              type=\"text\"\n              value={pattern.name}\n              onChange={(e) => dispatch(setName(e.target.value))}\n            />\n          </div>\n          <div>\n            <input\n              value={t(\"Save\") as string}\n              type=\"button\"\n              onClick={() => onSaveAction()}\n            />\n          </div>\n        </div>\n\n        <div>\n          <div>{t(\"Background image url\")}</div>\n          <div>\n            <input\n              type=\"text\"\n              value={imageFileName}\n              onChange={(e) => {\n                const value = e.target.value;\n                setImageFileName(value);\n                onBackgroundSelected(value);\n              }}\n            />\n          </div>\n        </div>\n\n        <BackgroundInput\n          onChange={(filename, img) => {\n            setImageFileName(filename);\n            onBackgroundSelected(img);\n          }}\n        />\n\n        <div>\n          <div>{t(\"Scale\")}</div>\n          <div>\n            <input\n              type=\"number\"\n              value={pattern.scale}\n              onChange={(e) => dispatch(setScale(e.target.valueAsNumber))}\n            />\n          </div>\n        </div>\n\n        <div>{t(\"Parameters\")}</div>\n        <Parameters />\n\n        <div>{t(\"Guides\")}</div>\n        {guideInputs}\n\n        <div>\n          <div>{t(\"gcode\")}</div>\n          <div>\n            <input\n              type=\"button\"\n              value={t(\"Generate\") as string}\n              onClick={() => onGcodeAction()}\n            />\n          </div>\n          <textarea\n            value={gcode}\n            readOnly={true}\n            onClick={(e) => (e.target as HTMLTextAreaElement).select()}\n          />\n        </div>\n      </form>\n    </ControlsWrapper>\n  );\n}\n","import { useAppSelector, useAppDispatch } from \"../app/hooks\";\nimport { selectToolMode, setToolState } from \"./toolsSlice\";\nimport { toggleMirror, selectMirror } from \"./patternSlice\";\nimport { useTranslation } from \"react-i18next\";\nimport { ActionCreators } from \"redux-undo\";\nimport { ControlsWrapper } from \"./ControlsWrapper\";\n\ninterface BaseButtonProps {\n  title: string;\n  tool: string;\n  toolMode: string;\n  onClick: Function;\n}\nconst BUTTON_LENGHT = 25;\n\ninterface ButtonProps extends BaseButtonProps {\n  children: React.ReactNode;\n}\nfunction Button({ title, tool, toolMode, onClick, children }: ButtonProps) {\n  return (\n    <button\n      title={title}\n      className={toolMode === tool ? \"active\" : \"\"}\n      onClick={() => onClick()}\n    >\n      {children}\n    </button>\n  );\n}\n\ninterface SvgPathButtonProps extends BaseButtonProps {\n  path: string;\n}\n\nfunction SvgPathButton({ path, ...props }: SvgPathButtonProps) {\n  return (\n    <Button {...props}>\n      <svg width={BUTTON_LENGHT} height={BUTTON_LENGHT}>\n        <path d={path} fillOpacity=\"0%\" />\n      </svg>\n    </Button>\n  );\n}\n\nconst MOVE_PATH = `M302.189 329.126H196.105l55.831 135.993c3.889 9.428-.555 19.999-9.444 23.999l-49.165 21.427c-9.165 4-19.443-.571-23.332-9.714l-53.053-129.136-86.664 89.138C18.729 472.71 0 463.554 0 447.977V18.299C0 1.899 19.921-6.096 30.277 5.443l284.412 292.542c11.472 11.179 3.007 31.141-12.5 31.141z`;\nconst HANDLE_PATH = `M6,0 Q30,20 6,25`;\nconst MIRROR_PATH = `M0,0 Q25,20 0,25 M25,0 Q0,20 25,25`;\nconst UNDO_PATH =\n  \"M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z\";\nconst REDO_PATH =\n  \"M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.54,15.22L3.9,16C4.95,12.81 7.95,10.5 11.5,10.5C13.45,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z\";\n\nexport default function ToolBox() {\n  const dispatch = useAppDispatch();\n  const mirror = useAppSelector(selectMirror);\n  const toolMode = useAppSelector(selectToolMode);\n  const { t } = useTranslation();\n\n  return (\n    <ControlsWrapper className=\"toolbox\">\n      <div className=\"tools\">\n        <Button\n          title={t(\"Move\")}\n          onClick={() => dispatch(setToolState(\"move\"))}\n          tool=\"move\"\n          toolMode={toolMode}\n        >\n          <svg viewBox=\"0 0 320 512\" width=\"25\" height=\"25\">\n            <path d={MOVE_PATH} />\n          </svg>\n        </Button>\n\n        <SvgPathButton\n          path=\"M10,0 V20\"\n          tool=\"vguide\"\n          toolMode={toolMode}\n          title={t(\"Vertical guide\")}\n          onClick={() => dispatch(setToolState(\"vguide\"))}\n        />\n\n        <SvgPathButton\n          path=\"M0,10 H20\"\n          tool=\"hguide\"\n          toolMode={toolMode}\n          title={t(\"Horizontal guide\")}\n          onClick={() => dispatch(setToolState(\"hguide\"))}\n        />\n\n        <Button\n          title={t(\"Add vertex\")}\n          onClick={() => dispatch(setToolState(\"handle\"))}\n          tool=\"handle\"\n          toolMode={toolMode}\n        >\n          <svg width={BUTTON_LENGHT} height={BUTTON_LENGHT}>\n            <circle\n              cx={BUTTON_LENGHT / 2}\n              cy={BUTTON_LENGHT / 2}\n              r={BUTTON_LENGHT * 0.25}\n              fill=\"#000\"\n            />\n          </svg>\n        </Button>\n\n        <SvgPathButton\n          title={t(\"Convert to curve\")}\n          onClick={() => dispatch(setToolState(\"curve\"))}\n          path={HANDLE_PATH}\n          tool=\"curve\"\n          toolMode={toolMode}\n        />\n\n        <SvgPathButton\n          title={t(\"Mirror\")}\n          onClick={() => dispatch(toggleMirror())}\n          path={MIRROR_PATH}\n          tool=\"mirror\"\n          toolMode={mirror ? \"mirror\" : \"\"}\n        />\n\n        <SvgPathButton\n          title={t(\"Undo\")}\n          onClick={() => dispatch(ActionCreators.undo())}\n          path={UNDO_PATH}\n          tool=\"undo\"\n          toolMode={\"\"}\n        />\n        <SvgPathButton\n          title={t(\"Redo\")}\n          onClick={() => dispatch(ActionCreators.redo())}\n          path={REDO_PATH}\n          tool=\"redo\"\n          toolMode={\"\"}\n        />\n      </div>\n    </ControlsWrapper>\n  );\n}\n","import React, { useState } from \"react\";\nimport Handles from \"./Handles\";\nimport { Guide } from \"./Guides\";\nimport { Guides, GUIDE_HORIZONTAL, GUIDE_VERTICAL } from \"./Guides\";\nimport GuideMeasurements from \"./GuideMeasurements\";\nimport Path from \"./Path\";\nimport gcode from \"../utils/gcode\";\nimport serialization from \"../utils/serialization\";\nimport Controls from \"./Controls\";\nimport ToolBox from \"./ToolBox\";\nimport mirrorPoints from \"./points\";\nimport { Vertex } from \"./points\";\nimport { useAppSelector, useAppDispatch } from \"../app/hooks\";\nimport {\n  selectPattern,\n  selectVertices,\n  selectGuides,\n  setName,\n  setScale,\n  toggleMirror,\n  clearVertices,\n  setVertices,\n  addVertex,\n  setVertexValue,\n  clearGuides,\n  addGuide,\n  setGuidePos,\n  finishDragging,\n} from \"./patternSlice\";\nimport {\n  ToolState,\n  selectToolMode,\n  setToolState as _setToolState,\n} from \"./toolsSlice\";\n\nconst TOOL_TYPES = {\n  move: \"move\",\n  handle: \"handle\",\n  hLine: \"hguide\",\n  vLine: \"vguide\",\n  clear: \"clear\",\n  curve: \"curve\",\n  // gcode: \"gcode\",\n};\n\nconst TOOL_KEYS: { [index: string]: any } = {\n  KeyN: TOOL_TYPES.move,\n  KeyP: TOOL_TYPES.handle,\n  KeyH: TOOL_TYPES.hLine,\n  KeyV: TOOL_TYPES.vLine,\n  KeyC: TOOL_TYPES.clear,\n  KeyS: TOOL_TYPES.curve,\n  // KeyG: TOOL_TYPES.gcode,\n};\n\nconst DEFAULT_SCALE = 1;\n\nexport default function Editor() {\n  let svg: any;\n  const dispatch = useAppDispatch();\n  const pattern = useAppSelector(selectPattern);\n  const guides = useAppSelector(selectGuides);\n  const vertices = useAppSelector(selectVertices);\n  const toolState = useAppSelector(selectToolMode);\n  const setToolState = (toolMode: ToolState) =>\n    dispatch(_setToolState(toolMode));\n  const [handleDraggingIndex, setHandleDraggingIndex] = useState(null);\n  const [guideDraggingIndex, setGuidDraggingIndex] = useState(null);\n  const [image, setImage] = useState(\"pattern.png\");\n  const [gcodeString, setGcodeString] = useState(\"\");\n\n  function addHandle(e: React.MouseEvent<HTMLElement>) {\n    if (e.altKey) {\n      dispatch(clearVertices());\n      return;\n    }\n    let pt = svg.createSVGPoint();\n    pt.x = e.clientX;\n    pt.y = e.clientY;\n    const cursorpt = pt.matrixTransform(svg.getScreenCTM().inverse());\n    dispatch(\n      addVertex({\n        anchorX: null,\n        anchorY: null,\n        x: cursorpt.x,\n        y: cursorpt.y,\n        type: \"end\",\n      })\n    );\n  }\n\n  function createGuide(\n    e: React.MouseEvent<HTMLElement>,\n    guideType: Guide[\"type\"]\n  ) {\n    let pt = svg.createSVGPoint();\n    pt.x = e.clientX;\n    pt.y = e.clientY;\n    const cursorpt = pt.matrixTransform(svg.getScreenCTM().inverse());\n    const guide: Guide = {\n      type: guideType,\n      originIndex: null,\n      pos: guideType === GUIDE_HORIZONTAL ? cursorpt.y : cursorpt.x,\n      length: 0,\n      lengthExpresion: 0,\n      direction: 1,\n      label: \"\",\n    };\n    return guide;\n  }\n\n  function addHGuide(e: React.MouseEvent<HTMLElement>) {\n    dispatch(addGuide(createGuide(e, GUIDE_HORIZONTAL)));\n  }\n\n  function addVGuide(e: React.MouseEvent<HTMLElement>) {\n    dispatch(addGuide(createGuide(e, GUIDE_VERTICAL)));\n  }\n\n  function handleGcodeAction() {\n    setGcodeString(\n      gcode(pattern.mirror ? mirrorPoints(vertices) : vertices, pattern.scale)\n    );\n  }\n\n  function handleKeyPress(e: React.KeyboardEvent<SVGElement>) {\n    const key = e.code;\n    if (key === \"KeyC\") {\n      if (e.shiftKey) {\n        dispatch(clearVertices());\n        dispatch(clearGuides());\n      }\n      setToolState(\"move\");\n    } else if (key === \"KeyG\") {\n      handleGcodeAction();\n      setToolState(\"move\");\n    } else if (key === \"KeyI\") {\n      let reversedVertices = [...vertices];\n      reversedVertices.reverse();\n      dispatch(setVertices(reversedVertices));\n      setToolState(\"move\");\n    } else if (key === \"KeyR\") {\n      if (vertices.length) {\n        const yAxis = vertices[0].x;\n        let reflectedVertices = vertices.map((vertex) => {\n          const newVertex: Vertex = { ...vertex };\n          newVertex.x = yAxis - (vertex.x - yAxis);\n          return newVertex;\n        });\n\n        dispatch(setVertices(reflectedVertices));\n      }\n      setToolState(\"move\");\n    } else if (key === \"KeyM\") {\n      dispatch(toggleMirror());\n    } else {\n      setToolState(TOOL_KEYS[key]);\n    }\n  }\n\n  function handleHandleClick(i: number) {\n    if (toolState !== TOOL_TYPES.curve) {\n      return;\n    }\n    let vertex = vertices[i];\n    let newVertex: Vertex = { ...vertex };\n\n    newVertex.type = \"control\";\n    const DELTA = 50;\n    newVertex.x = vertex.x + DELTA;\n    newVertex.y = vertex.y + DELTA;\n\n    let newVertexs = [...vertices];\n    newVertexs.splice(i, 0, newVertex);\n    dispatch(setVertices(newVertexs));\n  }\n\n  function handleDrag(e: React.MouseEvent<SVGElement>) {\n    if (handleDraggingIndex === null && guideDraggingIndex === null) {\n      return;\n    }\n\n    let pt = svg.createSVGPoint();\n    pt.x = e.clientX;\n    pt.y = e.clientY;\n    const cursorpt = pt.matrixTransform(svg.getScreenCTM().inverse());\n\n    if (handleDraggingIndex !== null) {\n      const SNAP_DISTANCE = 20;\n\n      //horizontals\n      let distance = 1000; //start with a big number to find the closests.\n      let snapHGuide: Guide | null = null;\n      let snapHGuideIndex = null;\n\n      guides.forEach((guide: Guide, i) => {\n        if (guide.type === GUIDE_HORIZONTAL) {\n          const newDistance = Math.abs(guide.pos - cursorpt.y);\n          if (newDistance < distance && newDistance < SNAP_DISTANCE) {\n            snapHGuide = guide;\n            snapHGuideIndex = i;\n            distance = newDistance;\n          }\n        }\n      });\n      if (snapHGuide) {\n        cursorpt.y = snapHGuide[\"pos\"]; //using dot notationg breaks ts??\n      }\n\n      //vertical\n      distance = 1000;\n      let snapVGuide = null;\n      let snapVGuideIndex = -1;\n      guides.forEach((guide, i) => {\n        if (guide.type === GUIDE_VERTICAL) {\n          const newDistance = Math.abs(guide.pos - cursorpt.x);\n          if (newDistance < distance && newDistance < SNAP_DISTANCE) {\n            snapVGuide = guide;\n            snapVGuideIndex = i;\n            distance = newDistance;\n          }\n        }\n      });\n      if (snapVGuide) {\n        cursorpt.x = snapVGuide[\"pos\"];\n      }\n\n      const vertex = {\n        type: vertices[handleDraggingIndex].type,\n        anchorY: snapHGuideIndex,\n        anchorX: snapVGuideIndex,\n        x: cursorpt.x,\n        y: cursorpt.y,\n      };\n      dispatch(\n        setVertexValue({\n          vertex,\n          index: handleDraggingIndex,\n        })\n      );\n    } else if (guideDraggingIndex !== null) {\n      const pos = {\n        x: cursorpt.x,\n        y: cursorpt.y,\n        index: guideDraggingIndex,\n      };\n      dispatch(setGuidePos(pos));\n    } else {\n      console.error(\"weird\");\n    }\n  }\n\n  function handleNewAction() {\n    console.log(\"new, clearing.\");\n    dispatch(clearVertices());\n    dispatch(clearGuides());\n    setToolState(\"move\");\n    setHandleDraggingIndex(null);\n    setGuidDraggingIndex(null);\n    dispatch(setScale(DEFAULT_SCALE));\n    dispatch(setName(\"\"));\n  }\n\n  function handleSaveAction() {\n    serialization.save();\n  }\n\n  function handleLoadAction(name: string) {\n    if (name === \"\") {\n      dispatch(setName(\"\"));\n      return;\n    } else if (name === pattern.name) {\n      return;\n    }\n    serialization.load(name);\n    setToolState(\"move\");\n    setHandleDraggingIndex(null);\n    setGuidDraggingIndex(null);\n  }\n\n  const TOOL_FUNCTIONS: { [index: string]: any } = {\n    move: () => {},\n    handle: addHandle,\n    hguide: addHGuide,\n    vguide: addVGuide,\n  };\n\n  const viewBoxWidth = 1000;\n  const viewBoxHeight = 600;\n  const viewBox = `0 0 ${viewBoxWidth} ${viewBoxHeight}`;\n  return (\n    <div\n      className=\"container\"\n      style={{ border: \"thin solid blue\" }}\n      // contentEditable=\"true\"\n    >\n      <div className=\"controls\">\n        <Controls\n          image={image}\n          onBackgroundSelected={setImage}\n          onNewAction={handleNewAction}\n          onSaveAction={handleSaveAction}\n          onLoadAction={handleLoadAction}\n          gcode={gcodeString}\n          onGcodeAction={handleGcodeAction}\n        />\n      </div>\n      <ToolBox />\n      <svg\n        id=\"svg\"\n        ref={(ref) => {\n          svg = ref;\n        }}\n        viewBox={viewBox}\n        className=\"background-img\"\n        style={{ border: \"thin solid red\", height: \"100vh\" }}\n        onClick={TOOL_FUNCTIONS[toolState]}\n        onMouseUp={() => {\n          setHandleDraggingIndex(null);\n          setGuidDraggingIndex(null);\n          dispatch(finishDragging());\n        }}\n        onMouseMove={handleDrag}\n        tabIndex={0}\n        onKeyPress={handleKeyPress}\n      >\n        <image href={image} height=\"100%\" />\n        <Path vertices={vertices} mirror={pattern.mirror} />\n        <GuideMeasurements\n          width={viewBoxWidth}\n          height={viewBoxHeight}\n          scale={pattern.scale}\n        />\n        <Guides\n          width={viewBoxWidth}\n          height={viewBoxHeight}\n          onMouseDown={setGuidDraggingIndex}\n        />\n        <Handles\n          vertices={vertices}\n          onMouseDown={setHandleDraggingIndex}\n          onClick={handleHandleClick}\n        />\n      </svg>\n    </div>\n  );\n}\n","import { Bezier } from \"bezier-js\";\nimport { Vertex } from \"../editor/points\";\n\nconst zSafe = 10;\nconst zCut = -5;\nconst feed = 2000;\n\nexport default function gcode(vertices: Vertex[], scale: number) {\n  if (!vertices.length) {\n    return \"\";\n  }\n\n  //TODO: set units instad of assuming mm.\n  const MM_TO_CM_FACTOR = 10;\n  scale *= MM_TO_CM_FACTOR;\n\n  //translate to 0 and flip Y to match common cnc coordinate systems.\n  const first = vertices[0]; //TODO: find the closest point to bot/left\n  vertices = vertices.map((vertex: Vertex) => {\n    let newVertex: Vertex = { ...vertex };\n    newVertex.x = (vertex.x - first.x) * scale;\n    newVertex.y = (vertex.y - first.y) * -scale;\n    return newVertex;\n  });\n\n  const oldVertices = vertices;\n  vertices = [...vertices];\n  console.log(\"generating gcode\");\n\n  const firstPoint = vertices.shift();\n  if (!firstPoint) {\n    return \"\"; // keeps ts happy\n  }\n\n  let g1Commands: string[] = [];\n  // let start = null;\n  let control: Vertex | null = null;\n  vertices.forEach((vertex, i) => {\n    i += 1; //ZOMG!!!! messedd up i's\n    if (vertex.type === \"control\") {\n      // start = vertices[i - 1];\n      control = vertex;\n      g1Commands.push(`(control ${i})`);\n      return;\n    }\n\n    if (control) {\n      const bezier = new Bezier(\n        oldVertices[i - 2].x,\n        oldVertices[i - 2].y,\n        oldVertices[i - 1].x,\n        oldVertices[i - 1].y,\n        vertex.x,\n        vertex.y\n      );\n      //TODO add steps arg.\n      const steps = 30;\n      bezier.getLUT(steps).forEach((step) => {\n        g1Commands.push(`G1 X${step.x} Y${step.y} (${i} step)`);\n      });\n      control = null;\n      // start = null;\n    } else {\n      g1Commands.push(`G1 X${vertex.x} Y${vertex.y} (${i})`);\n    }\n  });\n\n  const gcodeText = `G0 Z${zSafe}\nG0 X${firstPoint.x} Y${firstPoint.y} (0)\nG1 Z${zCut} F${feed}\n${g1Commands.join(\"\\n\")}\nG0 Z${zSafe}\n  `;\n\n  return gcodeText;\n}\n","import \"./App.scss\";\nimport \"./svg.scss\";\nimport Editor from \"./editor/Editor\";\n// import * as paths from \"./paths.js\";\n\nfunction App() {\n  // const Path = paths.Clock;\n  // return <Path />;\n\n  return <Editor />;\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport \"./i18n.ts\";\nimport App from \"./App\";\nimport { store } from \"./app/store\";\nimport { Provider } from \"react-redux\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}